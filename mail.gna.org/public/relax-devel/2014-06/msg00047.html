<!-- MHonArc v2.6.18 -->
<!--X-Subject: Re: [bug #22146] Unpacking of R2A and R2B is performed wrong for clustered "full" dispersion models -->
<!--X-From-R13: Febryf Szgrxæe Zvaarg &#60;gyvaargNaze&#45;erynk.pbz> -->
<!--X-Date: Fri, 06 Jun 2014 15:11:36 +0200 -->
<!--X-Message-Id: CA+CBx2Mccs&#45;kCgRtzeFXXux5ZqSJ0qWZe+_iSUVQG_jkr5&#45;m9Q@mail.gmail.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 20140606&#45;090858.sv20529.63087@gna.org -->
<!--X-Reference: CAED9pY8HfLjJSuOWA71Ny=DyKL9XL4mFO+CkMrbVfkaJrHjGvw@mail.gmail.com -->
<!--X-Reference: CA+CBx2PeVJsdFvPm8gZubmW6&#45;KVQiMnRxccjSpRjoibqsfjqJQ@mail.gmail.com -->
<!--X-Reference: CA+CBx2NwaT8fd0Jx_FdOf6eKOTiBxqm=_R&#45;P=brUwAtJWjWiJQ@mail.gmail.com -->
<!--X-Reference: CAED9pY&#45;&#45;xYkqQpkkGvaV7rCm0m1TR&#45;fYBtFiGmK=hChLnA6SVw@mail.gmail.com -->
<!--X-Reference: CAED9pY_CvOmgeMgsDi6E+VcDvW&#45;gt48YKUbDqXqzeaTWQZH0eg@mail.gmail.com -->
<!--X-Reference: CA+CBx2OgzxwN6BJj=0BUgKC_VHHUGC1AKkOqJE5fntsu9UevWw@mail.gmail.com -->
<!--X-Reference: CAED9pY&#45;yzkOcCxunHCnj_NzWSyuJ&#45;PStRobnPFf6b_2DSPAZ0w@mail.gmail.com -->
<!--X-Reference: CA+CBx2PvVUf&#45;TyqAJNLeO2owJgcA6NC5NRSXOahenWFKEV4a8w@mail.gmail.com -->
<!--X-Reference: CAED9pY8Ze9fqpAunTLnVQHv1&#45;hxVbTX86wy=b2G0x6sNv24oFw@mail.gmail.com -->
<!--X-Reference: CA+CBx2NY1_A4VF6_52YkFD_o&#45;6NcMwMhqDH5+8GD+XwreQZyKg@mail.gmail.com -->
<!--X-Reference: CAED9pY&#45;3RzchVFzBBRGUdF_uh=G1ayQprBr2ua3a6cYVkNwGLw@mail.gmail.com -->
<!--X-Head-End-->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: [bug #22146] Unpacking of R2A and R2B is performed wrong for clustered &quot;full&quot; dispersion models -- June 06, 2014 - 15:11</title>
<link rel="stylesheet" type="text/css" href="/mail.gna.org/archives-color-gna.css"> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<h2><img src="/mail.gna.org/images/mail.orig.png" width="48" height="48"
alt="mail" class="pageicon" />Re: [bug #22146] Unpacking of R2A and R2B is performed wrong for clustered &quot;full&quot; dispersion models</h2>
<br />
<div class="topmenu">
<a href="../" class="tabs">Others Months</a> | <a href="index.html#00047" class="tabs">Index by Date</a> | <a href="threads.html#00047" class="tabs">Thread Index</a><br />
<span class="smaller">&gt;&gt;&nbsp;&nbsp;
[<a href="msg00046.html">Date Prev</a>] [<a href="msg00048.html">Date Next</a>] [<a href="msg00046.html">Thread Prev</a>] [<a href="msg00048.html">Thread Next</a>]
</div>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h3><a name="header" href="#header">Header</a></h3>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul class="headdata">
<li class="menuitem">
<em>To</em>: &quot;Edward d'Auvergne&quot; &lt;edward@xxxxxxxxxxxxx&gt;</li>
<li class="menuitem">
<em>Date</em>: Fri, 6 Jun 2014 15:10:45 +0200</li>
<li class="menuitem">
<em>Cc</em>: &quot;Troels E. Linnet&quot; &lt;NO-REPLY.INVALID-ADDRESS@xxxxxxx&gt;, &quot;relax-devel@xxxxxxx&quot; &lt;relax-devel@xxxxxxx&gt;</li>
<li class="menuitem">
<em>Dkim-signature</em>: v=1; a=rsa-sha256; c=relaxed/relaxed; d=gmail.com; s=20120113; h=mime-version:sender:in-reply-to:references:from:date:message-id :subject:to:cc:content-type; bh=YMDR2WW2v0suzv0Z/HuPhiBhnxI45506Ib/R3hywL0M=; b=V2NjfFoWjk5LqyWOH71Jzt9Z/LzgcTTxVZ0a5QIHnzYOs5/+bmOBHzsC1lT4ujSwjw ZUxqCH64aqm1UHIS/POOpkNCSZdciAdDGGt8BxXk5Lflbskp7zmsGaA0jSYo5GzZhno0 2CHK0zoRmK/H+6OuQurJ8hXsWLM1ZTTNJj5hzhwgdjlueikgDj7Oql/EqpCQHFUeb1Yg 4bsV8dkfdehCVA96nhza2JHw0ZCQbiml/3Scth/8PhjwWOIVemV6WtFTSpT/Wf1TpkQ0 Pghv3xGsAEUf9BS2wZoAJnh46MJY6ag9GTqqNtyYom0ZiK6m09JerF4ApDNNbMb4nIuW l0Gw==</li>
<li class="menuitem">
<em>Message-id</em>: &lt;<a href="msg00047.html">CA+CBx2Mccs-kCgRtzeFXXux5ZqSJ0qWZe+_iSUVQG_jkr5-m9Q@mail.gmail.com</a>&gt;</li>
<li class="menuitem">
<em>References</em>: &lt;<a href="msg00034.html">20140606-090858.sv20529.63087@gna.org</a>&gt; &lt;CAED9pY8HfLjJSuOWA71Ny=DyKL9XL4mFO+CkMrbVfkaJrHjGvw@mail.gmail.com&gt; &lt;<a href="msg00036.html">CA+CBx2PeVJsdFvPm8gZubmW6-KVQiMnRxccjSpRjoibqsfjqJQ@mail.gmail.com</a>&gt; &lt;CA+CBx2NwaT8fd0Jx_FdOf6eKOTiBxqm=_R-P=brUwAtJWjWiJQ@mail.gmail.com&gt; &lt;CAED9pY--xYkqQpkkGvaV7rCm0m1TR-fYBtFiGmK=hChLnA6SVw@mail.gmail.com&gt; &lt;<a href="msg00040.html">CAED9pY_CvOmgeMgsDi6E+VcDvW-gt48YKUbDqXqzeaTWQZH0eg@mail.gmail.com</a>&gt; &lt;CA+CBx2OgzxwN6BJj=0BUgKC_VHHUGC1AKkOqJE5fntsu9UevWw@mail.gmail.com&gt; &lt;<a href="msg00042.html">CAED9pY-yzkOcCxunHCnj_NzWSyuJ-PStRobnPFf6b_2DSPAZ0w@mail.gmail.com</a>&gt; &lt;<a href="msg00043.html">CA+CBx2PvVUf-TyqAJNLeO2owJgcA6NC5NRSXOahenWFKEV4a8w@mail.gmail.com</a>&gt; &lt;CAED9pY8Ze9fqpAunTLnVQHv1-hxVbTX86wy=b2G0x6sNv24oFw@mail.gmail.com&gt; &lt;<a href="msg00045.html">CA+CBx2NY1_A4VF6_52YkFD_o-6NcMwMhqDH5+8GD+XwreQZyKg@mail.gmail.com</a>&gt; &lt;CAED9pY-3RzchVFzBBRGUdF_uh=G1ayQprBr2ua3a6cYVkNwGLw@mail.gmail.com&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
</div><!-- end headdata -->
<br />
<h3><a name="content" href="#content">Content</a></h3>
<div class="postedby">Posted by <strong>Troels Emtekær Linnet</strong> on June 06, 2014 - 15:11:</div>
<div class="msgdata">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre style="margin: 0em;">I tried:

        ## Experiments
        # Exp 1
        sfrq_1 = 500.0*1E6
        r20_key_1 = generate_r20_key(exp_type=EXP_TYPE_CPMG_SQ, frq=sfrq_1)
        time_T2_1 = 0.05
        ncycs_1 = range(2,22,2)
        # Here you define the direct R2eff errors (rad/s), as being added
or subtracted for the created R2eff point in the corresponding ncyc cpmg
frequence.
        #r2eff_errs_1 = [0.05, -0.05, 0.05, -0.05, 0.05, -0.05, 0.05,
-0.05, 0.05, -0.05, 0.05, -0.05, 0.05, -0.05, 0.05]
        r2eff_errs_1 = [0.0] * len(ncycs_1)
        exp_1 = [sfrq_1, time_T2_1, ncycs_1, r2eff_errs_1]

        sfrq_2 = 600.0*1E6
        r20_key_2 = generate_r20_key(exp_type=EXP_TYPE_CPMG_SQ, frq=sfrq_2)
        time_T2_2 = 0.06
        ncycs_2 = range(2,22,2)
        # Here you define the direct R2eff errors (rad/s), as being added
or subtracted for the created R2eff point in the corresponding ncyc cpmg
frequence.
        #r2eff_errs_2 = [0.05, -0.05, 0.05, -0.05, 0.05, -0.05, 0.05,
-0.05, 0.05, -0.05, 0.05, -0.05, 0.05, -0.05, 0.05, -0.05, 0.05]
        r2eff_errs_2 = [0.0] * len(ncycs_2)
        exp_2 = [sfrq_2, time_T2_2, ncycs_2, r2eff_errs_2]

        sfrq_3 = 700.0*1E6
        r20_key_3 = generate_r20_key(exp_type=EXP_TYPE_CPMG_SQ, frq=sfrq_3)
        time_T2_3 = 0.07
        ncycs_3 = range(2,22,2)
        # Here you define the direct R2eff errors (rad/s), as being added
or subtracted for the created R2eff point in the corresponding ncyc cpmg
frequence.
        #r2eff_errs_2 = [0.05, -0.05, 0.05, -0.05, 0.05, -0.05, 0.05,
-0.05, 0.05, -0.05, 0.05, -0.05, 0.05, -0.05, 0.05, -0.05, 0.05]
        r2eff_errs_3 = [0.0] * len(ncycs_3)
        exp_3 = [sfrq_3, time_T2_3, ncycs_3, r2eff_errs_3]

        # Collect all exps
        exps = [exp_1, exp_2, exp_3]

        R20 = [10.1, 10.2, 10.3, 100.1, 100.2, 100.3, 20.1, 20.2, 20.3,
200.1, 200.2, 200.3, 30.1, 30.2, 30.3, 300.1, 300.2, 300.3, 40.1, 40.2,
40.3, 400.1, 400.2, 400.3]
        #R20 = [10.1, 10.2, 10.3, 100.1, 100.2, 100.3, 20.1, 20.2, 20.3,
200.1, 200.2, 200.3]
        dw_arr = [1.0, 2.0, 3.0, 4.0]
        #dw_arr = [1.0, 2.0]
        pA_arr = [0.9]
        kex_arr = [1000.]

        spins = [
                ['Ala', 1, 'N', {'r2a': {r20_key_1: R20[0], r20_key_2:
R20[1], r20_key_3: R20[2]}, 'r2b': {r20_key_1: R20[3], r20_key_2: R20[4],
r20_key_3: R20[5]}, 'kex': kex_arr[0], 'pA': pA_arr[0], 'dw': dw_arr[0]}],
                ['Ala', 2, 'N', {'r2a': {r20_key_1: R20[6], r20_key_2:
R20[7], r20_key_3: R20[8]}, 'r2b': {r20_key_1: R20[9], r20_key_2: R20[10],
r20_key_3: R20[11]}, 'kex': kex_arr[0], 'pA': pA_arr[0], 'dw': dw_arr[1]}],
                ['Ala', 3, 'N', {'r2a': {r20_key_1: R20[12], r20_key_2:
R20[13], r20_key_3: R20[14]}, 'r2b': {r20_key_1: R20[15], r20_key_2:
R20[16], r20_key_3: R20[17]}, 'kex': kex_arr[0], 'pA': pA_arr[0], 'dw':
dw_arr[2]}],
                ['Ala', 4, 'N', {'r2a': {r20_key_1: R20[18], r20_key_2:
R20[19], r20_key_3: R20[20]}, 'r2b': {r20_key_1: R20[21], r20_key_2:
R20[22], r20_key_3: R20[23]}, 'kex': kex_arr[0], 'pA': pA_arr[0], 'dw':
dw_arr[3]}],
                ]

------

------------
relax&gt; grid_search(lower=[10.1, 10.2, 10.3, 100.1, 100.2, 100.3, 20.1,
20.2, 20.3, 200.1, 200.2, 200.3, 30.1, 30.2, 30.3, 300.1, 300.2, 300.3,
40.1, 40.2, 40.3, 400.1, 400.2, 400.3, 1.0, 2.0, 3.0, 4.0, 0.9, 1000.0],
upper=[10.1, 10.2, 10.3, 100.1, 100.2, 100.3, 20.1, 20.2, 20.3, 200.1,
200.2, 200.3, 30.1, 30.2, 30.3, 300.1, 300.2, 300.3, 40.1, 40.2, 40.3,
400.1, 400.2, 400.3, 1.0, 2.0, 3.0, 4.0, 0.9, 1000.0], inc=1,
constraints=True, verbosity=1)


Fitting to the spin block [':1@N', ':2@N', ':3@N', ':4@N']
----------------------------------------------------------

Unconstrained grid search size: 1 (constraints may decrease this size).


Grid search
~~~~~~~~~~~

Searching through 1 grid nodes.

Optimised parameter values:
r2a (SQ CPMG - 500.00000000 MHz)        10.100000000000000
r2a (SQ CPMG - 600.00000000 MHz)        10.199999999999999
r2a (SQ CPMG - 700.00000000 MHz)        10.300000000000001
r2b (SQ CPMG - 500.00000000 MHz)       100.099999999999994
r2b (SQ CPMG - 600.00000000 MHz)       100.199999999999989
r2b (SQ CPMG - 700.00000000 MHz)       100.299999999999997
r2a (SQ CPMG - 500.00000000 MHz)        20.100000000000001
r2a (SQ CPMG - 600.00000000 MHz)        20.199999999999999
r2a (SQ CPMG - 700.00000000 MHz)        20.300000000000004
r2b (SQ CPMG - 500.00000000 MHz)       200.099999999999966
r2b (SQ CPMG - 600.00000000 MHz)       200.199999999999989
r2b (SQ CPMG - 700.00000000 MHz)       200.300000000000011
r2a (SQ CPMG - 500.00000000 MHz)        30.100000000000001
r2a (SQ CPMG - 600.00000000 MHz)        30.199999999999999
r2a (SQ CPMG - 700.00000000 MHz)        30.300000000000004
r2b (SQ CPMG - 500.00000000 MHz)       300.100000000000023
r2b (SQ CPMG - 600.00000000 MHz)       300.199999999999989
r2b (SQ CPMG - 700.00000000 MHz)       300.300000000000011
r2a (SQ CPMG - 500.00000000 MHz)        40.099999999999994
r2a (SQ CPMG - 600.00000000 MHz)        40.200000000000003
r2a (SQ CPMG - 700.00000000 MHz)        40.299999999999997
r2b (SQ CPMG - 500.00000000 MHz)       400.100000000000023
r2b (SQ CPMG - 600.00000000 MHz)       400.199999999999932
r2b (SQ CPMG - 700.00000000 MHz)       400.300000000000011
dw                           1.000000000000000
dw                           2.000000000000000
dw                           3.000000000000000
dw                           4.000000000000000
pA                           0.900000000000000
kex                       1000.000000000000000
('CR72 full', 'Ala', ':1@N', 'r2a', 'SQ CPMG - 600.00000000 MHz', 10.2,
10.2)
('CR72 full', 'Ala', ':1@N', 'r2a', 'SQ CPMG - 500.00000000 MHz', 10.1,
10.1)
('CR72 full', 'Ala', ':1@N', 'r2a', 'SQ CPMG - 700.00000000 MHz', 10.3,
10.3)
('CR72 full', 'Ala', ':1@N', 'r2b', 'SQ CPMG - 600.00000000 MHz',
100.19999999999999, 100.2)
('CR72 full', 'Ala', ':1@N', 'r2b', 'SQ CPMG - 500.00000000 MHz', 100.1,
100.1)
('CR72 full', 'Ala', ':1@N', 'r2b', 'SQ CPMG - 700.00000000 MHz', 100.3,
100.3)
('CR72 full', 'Ala', ':2@N', 'r2a', 'SQ CPMG - 600.00000000 MHz', 20.2,
20.2)
('CR72 full', 'Ala', ':2@N', 'r2a', 'SQ CPMG - 500.00000000 MHz', 20.1,
20.1)
('CR72 full', 'Ala', ':2@N', 'r2a', 'SQ CPMG - 700.00000000 MHz',
20.300000000000004, 20.3)
('CR72 full', 'Ala', ':2@N', 'r2b', 'SQ CPMG - 600.00000000 MHz', 200.2,
200.2)
('CR72 full', 'Ala', ':2@N', 'r2b', 'SQ CPMG - 500.00000000 MHz',
200.09999999999997, 200.1)
('CR72 full', 'Ala', ':2@N', 'r2b', 'SQ CPMG - 700.00000000 MHz', 200.3,
200.3)
('CR72 full', 'Ala', ':3@N', 'r2a', 'SQ CPMG - 600.00000000 MHz', 30.2,
30.2)
('CR72 full', 'Ala', ':3@N', 'r2a', 'SQ CPMG - 500.00000000 MHz', 30.1,
30.1)
('CR72 full', 'Ala', ':3@N', 'r2a', 'SQ CPMG - 700.00000000 MHz',
30.300000000000004, 30.3)
('CR72 full', 'Ala', ':3@N', 'r2b', 'SQ CPMG - 600.00000000 MHz', 300.2,
300.2)
('CR72 full', 'Ala', ':3@N', 'r2b', 'SQ CPMG - 500.00000000 MHz', 300.1,
300.1)
('CR72 full', 'Ala', ':3@N', 'r2b', 'SQ CPMG - 700.00000000 MHz', 300.3,
300.3)
('CR72 full', 'Ala', ':4@N', 'r2a', 'SQ CPMG - 600.00000000 MHz', 40.2,
40.2)
('CR72 full', 'Ala', ':4@N', 'r2a', 'SQ CPMG - 500.00000000 MHz',
40.099999999999994, 40.1)
('CR72 full', 'Ala', ':4@N', 'r2a', 'SQ CPMG - 700.00000000 MHz', 40.3,
40.3)
('CR72 full', 'Ala', ':4@N', 'r2b', 'SQ CPMG - 600.00000000 MHz',
400.19999999999993, 400.2)
('CR72 full', 'Ala', ':4@N', 'r2b', 'SQ CPMG - 500.00000000 MHz', 400.1,
400.1)
('CR72 full', 'Ala', ':4@N', 'r2b', 'SQ CPMG - 700.00000000 MHz', 400.3,
400.3)

--------

It jumps over the target function?

This is a little weird?

Best
Troels



2014-06-06 15:02 GMT+02:00 Edward d'Auvergne &lt;edward@xxxxxxxxxxxxx&gt;:

</pre><blockquote class="blockquote"><pre style="margin: 0em;">Hi,

Some more information is needed, as it's not possible to tell where
this stopped.  A good idea would be to turn up the verbosity level to
see what minfx is doing.  Did you call the grid_search user function?
Or the minimise user function?  Did the grid search say something like
&quot;Searching through 1 grid nodes&quot;?

Regards,

Edward



On 6 June 2014 14:48, Troels Emtekær Linnet &lt;tlinnet@xxxxxxxxxxxxx&gt; wrote:
</pre><blockquote class="blockquote"><pre style="margin: 0em;">Hi Edward.

When I try to do a grid search, it does not initalize func_CR72_full in
</pre></blockquote><pre style="margin: 0em;">the
</pre><blockquote class="blockquote"><pre style="margin: 0em;">target function?

If I make
import sys
sys.exit()

It does not stop?
Only if I do a minimise, it stops?

It is in
specific_analyses/relax_disp/optimisation.py
line 745

Inserting
            print model.func.im_func.__name__
gives func_CR72_full

How does it know how to unpack and calculate?

Best
Troels


2014-06-06 12:32 GMT+02:00 Edward d'Auvergne &lt;edward@xxxxxxxxxxxxx&gt;:

</pre><blockquote class="blockquote"><pre style="margin: 0em;">Hi,

That sounds good.  Maybe it's best to have the number of fields and
number of spins set to something different and not to 2?  That way the
unpacking is stressed as much as possible and there cannot be a
accidental swap of the field and spin dimensions being unnoticed by
the test.  This is not likely, but I've encountered enough weird and
supposedly impossible situations in the development of relax that it
would not surprise me.

Cheers,

Edward

On 6 June 2014 12:27, Troels Emtekær Linnet &lt;tlinnet@xxxxxxxxxxxxx&gt;
</pre></blockquote></blockquote><pre style="margin: 0em;">wrote:
</pre><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><pre style="margin: 0em;">Check.

I am generating R2eff data for 3 fields, and 3 spins, for full model.
I will put the data in
test_suite/shared_data/dispersion/bug_22146_unpacking_r2a_r2b_cluster

Best
Troels


2014-06-06 12:11 GMT+02:00 Edward d'Auvergne &lt;edward@xxxxxxxxxxxxx&gt;:

</pre><blockquote class="blockquote"><pre style="margin: 0em;">Hi,

Right, you have the 2 parameters in the self.num_spins*2 part.  And I
forgot about the parameters being different for each field.  It would
be good to then have a multi-field and multi-spin cluster system test
to really make sure that relax operates correctly, especially with
</pre></blockquote></blockquote></blockquote></blockquote><pre style="margin: 0em;">the
</pre><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><pre style="margin: 0em;">data going into the target function and the subsequently unpacking
</pre></blockquote></blockquote></blockquote></blockquote><pre style="margin: 0em;">the
</pre><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><pre style="margin: 0em;">results into the relax data store.  For example someone might modify
the loop_parameters() function - this concept could be migrated into
the specific API and converted into a common mechanism for all the
analysis types as it is quite powerful - and they may not know that
the change they just made broke code in the
target_functions.relax_disp module.

Cheers,

Edward


On 6 June 2014 12:05, Troels Emtekær Linnet &lt;tlinnet@xxxxxxxxxxxxx&gt;
wrote:
</pre><blockquote class="blockquote"><pre style="margin: 0em;">Hi Ed.

The implementations needs:
        R20 = params[:self.end_index[1]].reshape(self.num_spins*2,
self.num_frq)
        R20A = R20[::2].flatten()
        R20B = R20[1::2].flatten()





2014-06-06 11:55 GMT+02:00 Edward d'Auvergne &lt;edward@xxxxxxxxxxxxx
</pre></blockquote></blockquote></blockquote></blockquote><pre style="margin: 0em;">:
</pre><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><pre style="margin: 0em;">

</pre><blockquote class="blockquote"><pre style="margin: 0em;">The different unpacking implementations can be tested with the
timeit
Python module to see which is fastest


(
</pre></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><pre style="margin: 0em;"><a  rel="nofollow" href="http://thread.gmane.org/gmane.science.nmr.relax.devel/5937/focus=6010">http://thread.gmane.org/gmane.science.nmr.relax.devel/5937/focus=6010</a>).
</pre><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><pre style="margin: 0em;">

Cheers,

Edward



On 6 June 2014 11:53, Edward d'Auvergne &lt;edward@xxxxxxxxxxxxx&gt;
wrote:
</pre><blockquote class="blockquote"><pre style="margin: 0em;">Hi,

In this case, I think 'num_frq' should be fixed to 2.  This
dimension
corresponds to the parameters R20A and R20B so it is always
</pre></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><pre style="margin: 0em;">fixed
</pre><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><pre style="margin: 0em;">to
2.

Regards,

Edward



On 6 June 2014 11:51, Troels Emtekær Linnet
&lt;tlinnet@xxxxxxxxxxxxx&gt;
wrote:
</pre><blockquote class="blockquote"><pre style="margin: 0em;">Hi.

Another way is:

ml = params[:end_index[1]].reshape(num_spins*2, num_frq)
R20A = ml[::2].flatten()
R20B = ml[1::2].flatten()


Best
Troels



2014-06-06 11:39 GMT+02:00 Troels Emtekær Linnet
&lt;tlinnet@xxxxxxxxxxxxx&gt;:

</pre><blockquote class="blockquote"><pre style="margin: 0em;">There is no doubt that it is the unpacking of the R20A and
</pre></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><pre style="margin: 0em;">R20B
</pre><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><pre style="margin: 0em;">in
the
target function.

I was thinking of creating a function, which do the the
unpacking.

This unpacking function could then be tested with a unit test?

What do you think?
Where should I position such a function?

Best
Troels



2014-06-06 11:26 GMT+02:00 Edward d'Auvergne
&lt;edward@xxxxxxxxxxxxx&gt;:
</pre><blockquote class="blockquote"><pre style="margin: 0em;">

Hi Troels,


The best way to handle this is to first create a unit test of
the


</pre></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><pre style="margin: 0em;">specific_analyses.relax_disp.parameters.disassemble_param_vector()
</pre><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><pre style="margin: 0em;">where the problem is likely to be most easily found.  I don't
understand how this could be a problem as the
assemble_param_vector()
and disassemble_param_vector() functions both call the same
loop_parameters() function for the ordering of the parameter
values!
Maybe the problem is in the unpacking of the parameter vector
in
the
target functions themselves, for example in the full B14
</pre></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><pre style="margin: 0em;">model:
</pre><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><pre style="margin: 0em;">


    def func_B14_full(self, params):
        &quot;&quot;&quot;Target function for the Baldwin (2014) 2-site
</pre></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><pre style="margin: 0em;">exact
</pre><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><pre style="margin: 0em;">solution model for all time scales.

        This assumes that pA &gt; pB, and hence this must be
implemented
as a constraint.


        @param params:  The vector of parameter values.
        @type params:   numpy rank-1 float array
        @return:        The chi-squared value.
        @rtype:         float
        &quot;&quot;&quot;

        # Scaling.
        if self.scaling_flag:
            params = dot(params, self.scaling_matrix)

        # Unpack the parameter values.
        R20A = params[:self.end_index[0]]
        R20B = params[self.end_index[0]:self.end_index[1]]
        dw = params[self.end_index[1]:self.end_index[2]]
        pA = params[self.end_index[2]]
        kex = params[self.end_index[2]+1]

        # Calculate and return the chi-squared value.
        return self.calc_B14_chi2(R20A=R20A, R20B=R20B,
</pre></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><pre style="margin: 0em;">dw=dw,
</pre><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><pre style="margin: 0em;">pA=pA,
kex=kex)


This R20A and R20B unpacking might be the failure point as
</pre></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><pre style="margin: 0em;">this
</pre><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><pre style="margin: 0em;">may
not match the loop_parameters() function - which it must!  In
any
case, having a unit or system test catch the problem would be
very
useful for the stability of the dispersion analysis in relax.

A code example might be useful:

R20_params = array([1, 2, 3, 4])
R20A, R20B = transpose(R20_params.reshape(2, 2)
print(R20A)
print(R20B)

You should see that R20A is [1, 3], and R20B is [2, 4].  This
is
how
the parameters are handled in the loop_parameters() function
which
defines the parameter vector in all parts of relax.  There
might
be a
quicker way to unpack the parameters, but such an idea could
</pre></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><pre style="margin: 0em;">be
</pre><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><pre style="margin: 0em;">used
for the target functions.

Cheers,

Edward

On 6 June 2014 11:08, Troels E. Linnet
&lt;NO-REPLY.INVALID-ADDRESS@xxxxxxx&gt;
wrote:
</pre><blockquote class="blockquote"><pre style="margin: 0em;">URL:
  &lt;<a  rel="nofollow" href="http://gna.org/bugs/?22146">http://gna.org/bugs/?22146</a>&gt;

                 Summary: Unpacking of R2A and R2B is
performed
wrong
for
clustered &quot;full&quot; dispersion models
                 Project: relax
            Submitted by: tlinnet
            Submitted on: Fri 06 Jun 2014 09:08:58 AM UTC
                Category: relax's source code
Specific analysis category: Relaxation dispersion
                Priority: 9 - Immediate
                Severity: 4 - Important
                  Status: None
             Assigned to: None
         Originator Name:
        Originator Email:
             Open/Closed: Open
                 Release: Repository: trunk
         Discussion Lock: Any
        Operating System: All systems

    _______________________________________________________

Details:

The unpacking of the R2A and R2B parameters in the &quot;full&quot;
model
is
performed
wrong.
This will happen performing a clustered analysis, using one
of
the
&quot;full&quot;
models.

This bug affect all analysis performed running with a
</pre></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><pre style="margin: 0em;">&quot;full&quot;
</pre><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><pre style="margin: 0em;">model,
with
clustered residues.

The bug is located in the target function:
./target_functions/relax_disp.py

For all the &quot;func_MODEL_full&quot;, the unpacking of:
R20A = params[:self.end_index[0]]
R20B = params[self.end_index[0]:self.end_index[1]]

This is wrong, since the &quot;params&quot; list, is ordered:
[spin, spin, spin, [dw], pA, kex], where spin =
</pre></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><pre style="margin: 0em;">[nr_frq*r2a,
</pre><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><pre style="margin: 0em;">nr_frq*r2b]

This ordering happens in:
./specific_analysis/relax_disp/parameters.py
in the loop_parameters.py

A possible solutions i shown below.
This alter the unpacking of the parameters.

An example of profiling_cr72.py is attached.
This can be downloaded, and run in base folder of relax:
./profiling_cr72.py .

This is with 3 frq, and 3 spins.

The current implementations would unpack:
('R20A', array([  2.,   2.,   2.,   4.,   4.,   4.,  12.,
12.,
12.]),
9)
('R20B', array([ 14.,  14.,  14.,  22.,  22.,  22.,  24.,
24.,
24.]),
9)

R2A is 2, 12, 22 for the spins 0-3
R2B is, 4, 14, 24 for the spins 0-3

The suggested unpacking loop, unpacks to:
('R20A', array([  2.,   2.,   2.,  12.,  12.,  12.,  22.,
22.,
22.]),
9)
('R20B', array([  4.,   4.,   4.,  14.,  14.,  14.,  24.,
24.,
24.]),
9)


-------
from numpy import array, concatenate, delete, index_exp
import numpy

p = array([  1.000000000000000e+01, 1.000000000000000e+01,
1.100000000000000e+01
, 1.100000000000000e+01, 1.000000000000000e+01,
1.000000000000000e+01
, 1.100000000000000e+01, 1.100000000000000e+01,
1.000000000000000e+00
, 1.000000000000000e+00, 9.000000000000000e-01,
1.000000000000000e+03])

e = [4, 8, 10]

# Now
r2a = p[:e[0]]
print r2a
r2b = p[e[0]:e[1]]
print r2b
dw = p[e[1]:e[2]]
print dw
pA = p[e[2]]
print pA
kex = p[e[2]+1]
print kex

print &quot;new&quot;
ns = 2
nf = 2

ml = p[:e[1]]

R20A = array([])
R20B = array([])
for i in range(0, ns):
    # Array sorted per [spin, spin, spin], where spin =
[nr_frq*r2a,
nr_frq*r2b]
    spin_AB = ml[:nf*2]
    ml = delete(ml, numpy.s_[:nf*2])
    R20A = concatenate([R20A, spin_AB[:nf] ])
    R20B = concatenate([R20B, spin_AB[nf:] ])

print R20A
print R20B
print dw
print pA
print kex



    _______________________________________________________

File Attachments:


-------------------------------------------------------
Date: Fri 06 Jun 2014 09:08:58 AM UTC  Name:
profiling_cr72.py
Size:
17kB
By: tlinnet

&lt;<a  rel="nofollow" href="http://gna.org/bugs/download.php?file_id=20938">http://gna.org/bugs/download.php?file_id=20938</a>&gt;

    _______________________________________________________

Reply to this item at:

  &lt;<a  rel="nofollow" href="http://gna.org/bugs/?22146">http://gna.org/bugs/?22146</a>&gt;

_______________________________________________
  Message sent via/by Gna!
  <a  rel="nofollow" href="http://gna.org/">http://gna.org/</a>


_______________________________________________
relax (<a  rel="nofollow" href="http://www.nmr-relax.com">http://www.nmr-relax.com</a>)

This is the relax-devel mailing list
relax-devel@xxxxxxx

To unsubscribe from this list, get a password
reminder, or change your subscription options,
visit the list information page at
<a  rel="nofollow" href="http://www.nmr-relax.com/mail.gna.org/listinfo/relax-devel">https://mail.gna.org/listinfo/relax-devel</a>
</pre></blockquote></blockquote><pre style="margin: 0em;">


</pre></blockquote><pre style="margin: 0em;">

</pre></blockquote></blockquote></blockquote><pre style="margin: 0em;">


</pre></blockquote></blockquote><pre style="margin: 0em;">


</pre></blockquote></blockquote><pre style="margin: 0em;">


</pre></blockquote><pre style="margin: 0em;">

</pre></blockquote><pre style="margin: 0em;">

</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div><!-- end msgdata -->
<br />
<h3><a name="related" href="#related">Related Messages</a></h3>
<div class="relateddata">
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00048" href="msg00048.html">Re: [bug #22146] Unpacking of R2A and R2B is performed wrong for clustered &quot;full&quot; dispersion models</a></strong>
<ul><li><em>From:</em> Troels Emtekær Linnet</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00034" href="msg00034.html">[bug #22146] Unpacking of R2A and R2B is performed wrong for clustered &quot;full&quot; dispersion models</a></strong>
<ul><li><em>From:</em> Troels E. Linnet</li></ul></li>
<li><strong><a name="00035" href="msg00035.html">Re: [bug #22146] Unpacking of R2A and R2B is performed wrong for clustered &quot;full&quot; dispersion models</a></strong>
<ul><li><em>From:</em> Edward d'Auvergne</li></ul></li>
<li><strong><a name="00036" href="msg00036.html">Re: [bug #22146] Unpacking of R2A and R2B is performed wrong for clustered &quot;full&quot; dispersion models</a></strong>
<ul><li><em>From:</em> Troels Emtekær Linnet</li></ul></li>
<li><strong><a name="00037" href="msg00037.html">Re: [bug #22146] Unpacking of R2A and R2B is performed wrong for clustered &quot;full&quot; dispersion models</a></strong>
<ul><li><em>From:</em> Troels Emtekær Linnet</li></ul></li>
<li><strong><a name="00039" href="msg00039.html">Re: [bug #22146] Unpacking of R2A and R2B is performed wrong for clustered &quot;full&quot; dispersion models</a></strong>
<ul><li><em>From:</em> Edward d'Auvergne</li></ul></li>
<li><strong><a name="00040" href="msg00040.html">Re: [bug #22146] Unpacking of R2A and R2B is performed wrong for clustered &quot;full&quot; dispersion models</a></strong>
<ul><li><em>From:</em> Edward d'Auvergne</li></ul></li>
<li><strong><a name="00041" href="msg00041.html">Re: [bug #22146] Unpacking of R2A and R2B is performed wrong for clustered &quot;full&quot; dispersion models</a></strong>
<ul><li><em>From:</em> Troels Emtekær Linnet</li></ul></li>
<li><strong><a name="00042" href="msg00042.html">Re: [bug #22146] Unpacking of R2A and R2B is performed wrong for clustered &quot;full&quot; dispersion models</a></strong>
<ul><li><em>From:</em> Edward d'Auvergne</li></ul></li>
<li><strong><a name="00043" href="msg00043.html">Re: [bug #22146] Unpacking of R2A and R2B is performed wrong for clustered &quot;full&quot; dispersion models</a></strong>
<ul><li><em>From:</em> Troels Emtekær Linnet</li></ul></li>
<li><strong><a name="00044" href="msg00044.html">Re: [bug #22146] Unpacking of R2A and R2B is performed wrong for clustered &quot;full&quot; dispersion models</a></strong>
<ul><li><em>From:</em> Edward d'Auvergne</li></ul></li>
<li><strong><a name="00045" href="msg00045.html">Re: [bug #22146] Unpacking of R2A and R2B is performed wrong for clustered &quot;full&quot; dispersion models</a></strong>
<ul><li><em>From:</em> Troels Emtekær Linnet</li></ul></li>
<li><strong><a name="00046" href="msg00046.html">Re: [bug #22146] Unpacking of R2A and R2B is performed wrong for clustered &quot;full&quot; dispersion models</a></strong>
<ul><li><em>From:</em> Edward d'Auvergne</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
</div><!-- end relateddata -->
<!-- NoBotLinksApartFromRelatedMessages -->

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
<div class="footer"></div><br />
<div class="right">Powered by <a href="http://www.mhonarc.org">MHonArc</a>, Updated Fri Jun 06 15:20:10 2014</div>  
</body>
</html>
