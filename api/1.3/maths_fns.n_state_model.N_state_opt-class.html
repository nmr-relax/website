<?xml version="1.0" encoding="ascii"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>maths_fns.n_state_model.N_state_opt</title>

  <!--Epydoc setup-->
  <link rel="stylesheet" href="epydoc.css" type="text/css" />
  <script type="text/javascript" src="epydoc.js"></script>

  <!--Mobile device support-->
  <meta name=viewport content="width=device-width, initial-scale=1">

  <!--Google analytics JS-->
  <script type="text/javascript">

    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-30096326-1']);
    _gaq.push(['_setDomainName', 'nmr-relax.com']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();

  </script>
</head>

<body bgcolor="white" text="black" link="blue" vlink="#204080"
      alink="#204080">
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Project homepage -->
      <th class="navbar" align="right" width="100%">
        <table border="0" cellpadding="0" cellspacing="0">
          <tr><th class="navbar" align="center"
            ><a class="navbar" target="_top" href="http://www.nmr-relax.com">relax</a></th>
          </tr></table></th>
  </tr>
</table>
<table width="100%" cellpadding="0" cellspacing="0">
  <tr valign="top">
    <td width="100%">
      <span class="breadcrumbs">
        <a href="maths_fns-module.html">Package&nbsp;maths_fns</a> ::
        <a href="maths_fns.n_state_model-module.html">Module&nbsp;n_state_model</a> ::
        Class&nbsp;N_state_opt
      </span>
    </td>
    <td>
      <table cellpadding="0" cellspacing="0">
        <!-- hide/show private -->
        <tr><td align="right"><span class="options">[<a href="javascript:void(0);" class="privatelink"
    onclick="toggle_private();">hide&nbsp;private</a>]</span></td></tr>
        <tr><td align="right"><span class="options"
            >[<a href="frames.html" target="_top">frames</a
            >]&nbsp;|&nbsp;<a href="maths_fns.n_state_model.N_state_opt-class.html"
            target="_top">no&nbsp;frames</a>]</span></td></tr>
      </table>
    </td>
  </tr>
</table>
<!-- ==================== CLASS DESCRIPTION ==================== -->
<h1 class="epydoc">Class N_state_opt</h1><p class="nomargin-top"><span class="codelink"><a href="maths_fns.n_state_model-pysrc.html#N_state_opt">source&nbsp;code</a></span></p>
<p>Class containing the target function of the optimisation of the 
  N-state model.</p>

<!-- ==================== INSTANCE METHODS ==================== -->
<a name="section-InstanceMethods"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Instance Methods</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-InstanceMethods"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="maths_fns.n_state_model.N_state_opt-class.html#__init__" class="summary-sig-name">__init__</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">model</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">N</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">init_params</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">probs</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">full_tensors</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">red_data</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">red_errors</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">full_in_ref_frame</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">fixed_tensors</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">pcs</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">pcs_errors</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">pcs_weights</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">rdcs</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">rdc_errors</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">rdc_weights</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">xh_vect</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">temp</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">frq</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">dip_const</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">atomic_pos</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">paramag_centre</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">scaling_matrix</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">centre_fixed</span>=<span class="summary-sig-default">True</span>)</span><br />
      Set up the class instance for optimisation.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="maths_fns.n_state_model-pysrc.html#N_state_opt.__init__">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">float</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="maths_fns.n_state_model.N_state_opt-class.html#func_2domain" class="summary-sig-name">func_2domain</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">params</span>)</span><br />
      The target function for optimisation of the 2-domain N-state model.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="maths_fns.n_state_model-pysrc.html#N_state_opt.func_2domain">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">float</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="maths_fns.n_state_model.N_state_opt-class.html#func_population" class="summary-sig-name">func_population</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">params</span>)</span><br />
      The target function for optimisation of the flexible population 
      N-state model.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="maths_fns.n_state_model-pysrc.html#N_state_opt.func_population">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">float</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="maths_fns.n_state_model.N_state_opt-class.html#func_tensor_opt" class="summary-sig-name">func_tensor_opt</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">params</span>)</span><br />
      The target function for optimisation of the alignment tensor from RDC
      and/or PCS data.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="maths_fns.n_state_model-pysrc.html#N_state_opt.func_tensor_opt">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">numpy rank-1 array</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="maths_fns.n_state_model.N_state_opt-class.html#dfunc_population" class="summary-sig-name">dfunc_population</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">params</span>)</span><br />
      The gradient function for optimisation of the flexible population 
      N-state model.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="maths_fns.n_state_model-pysrc.html#N_state_opt.dfunc_population">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">numpy rank-1 array</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="maths_fns.n_state_model.N_state_opt-class.html#dfunc_tensor_opt" class="summary-sig-name">dfunc_tensor_opt</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">params</span>)</span><br />
      The gradient function for optimisation of the alignment tensor from 
      RDC and/or PCS data.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="maths_fns.n_state_model-pysrc.html#N_state_opt.dfunc_tensor_opt">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">numpy rank-2 array</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="maths_fns.n_state_model.N_state_opt-class.html#d2func_population" class="summary-sig-name">d2func_population</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">params</span>)</span><br />
      The Hessian function for optimisation of the flexible population 
      N-state model.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="maths_fns.n_state_model-pysrc.html#N_state_opt.d2func_population">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">numpy rank-2 array</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="maths_fns.n_state_model.N_state_opt-class.html#d2func_tensor_opt" class="summary-sig-name">d2func_tensor_opt</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">params</span>)</span><br />
      The Hessian function for optimisation of the alignment tensor from 
      RDC and/or PCS data.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="maths_fns.n_state_model-pysrc.html#N_state_opt.d2func_tensor_opt">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="paramag_info"></a><span class="summary-sig-name">paramag_info</span>(<span class="summary-sig-arg">self</span>)</span><br />
      Calculate the paramagnetic centre to spin vectors, distances and 
      constants.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="maths_fns.n_state_model-pysrc.html#N_state_opt.paramag_info">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
</table>
<!-- ==================== METHOD DETAILS ==================== -->
<a name="section-MethodDetails"></a>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Method Details</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-MethodDetails"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
</table>
<a name="__init__"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">__init__</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">model</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">N</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">init_params</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">probs</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">full_tensors</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">red_data</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">red_errors</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">full_in_ref_frame</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">fixed_tensors</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">pcs</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">pcs_errors</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">pcs_weights</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">rdcs</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">rdc_errors</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">rdc_weights</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">xh_vect</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">temp</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">frq</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">dip_const</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">atomic_pos</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">paramag_centre</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">scaling_matrix</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">centre_fixed</span>=<span class="sig-default">True</span>)</span>
    <br /><em class="fname">(Constructor)</em>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="maths_fns.n_state_model-pysrc.html#N_state_opt.__init__">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Set up the class instance for optimisation.</p>
  <h1 class="heading">The N-state models</h1>
    <p>All constant data required for the N-state model are initialised 
    here.  Depending on the base data used for optimisation, different data
    structures can be supplied.  However a number of structures must be 
    provided for the N-state model.  These are:</p>
    <ul>
      <li>
        model, the type of N-state model.  This can be '2-domain', 
        'population', or 'fixed'.
      </li>
      <li>
        N, the number of states (or structures).
      </li>
      <li>
        init_params, the initial parameter values.
      </li>
      <li>
        scaling_matrix, the matrix used for parameter scaling during 
        optimisation.
      </li>
    </ul>
    <h2 class="heading">2-domain N-state model</h2>
      <p>If the model type is set to '2-domain', then the following data 
      structures should be supplied:</p>
      <ul>
        <li>
          full_tensors, the alignment tensors in matrix form.
        </li>
        <li>
          red_data, the alignment tensors in 5D form in a rank-1 array.
        </li>
        <li>
          red_errors, the alignment tensor errors in 5D form in a rank-1 
          array.  This data is not obligatory.
        </li>
        <li>
          full_in_ref_frame, an array of flags specifying if the tensor in 
          the reference frame is the full or reduced tensor.
        </li>
      </ul>
  <h1 class="heading">The population N-state model</h1>
    <p>In this model, populations are optimised for each state.  
    Additionally the alignment tensors for anisotropic data can also be 
    optimised if they have not been supplied (through the full_tensors 
    arg).</p>
    <h2 class="heading">PCS base data</h2>
      <p>If pseudocontact shift data is to be used for optimisation, then 
      the following should be supplied:</p>
      <ul>
        <li>
          pcs, the pseudocontact shifts.
        </li>
        <li>
          pcs_errors, the optional pseudocontact shift error values.
        </li>
        <li>
          temp, the temperatures of the experiments.
        </li>
        <li>
          frq, the frequencies of the experiments.
        </li>
      </ul>
    <h2 class="heading">PCS and PRE base data</h2>
      <p>If either pseudocontact shift or PRE data is to be used for 
      optimisation, then the following should be supplied:</p>
      <ul>
        <li>
          atomic_pos, the positions of all atoms.
        </li>
        <li>
          paramag_centre, the paramagnetic centre position.
        </li>
      </ul>
    <h2 class="heading">RDC base data</h2>
      <p>If residual dipolar coupling data is to be used for optimisation, 
      then the following should be supplied:</p>
      <ul>
        <li>
          rdcs, the residual dipolar couplings.
        </li>
        <li>
          rdc_errors, the optional residual dipolar coupling errors.
        </li>
        <li>
          xh_vect, the heteronucleus to proton unit vectors.
        </li>
        <li>
          dip_const, the dipolar constants.
        </li>
      </ul>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>model</code></strong> (str) - The N-state model type.  This can be one of '2-domain', 
          'population' or 'fixed'.</li>
        <li><strong class="pname"><code>N</code></strong> (int) - The number of states.</li>
        <li><strong class="pname"><code>init_params</code></strong> (numpy float64 array) - The initial parameter values.  Optimisation must start at some 
          point!</li>
        <li><strong class="pname"><code>probs</code></strong> (list of float) - The probabilities for each state c.  The length of this list 
          should be equal to N.</li>
        <li><strong class="pname"><code>full_tensors</code></strong> (list of rank-2, 3D numpy arrays) - An array of the {Sxx, Syy, Sxy, Sxz, Syz} values for all full 
          tensors.  The format is [Sxx1, Syy1, Sxy1, Sxz1, Syz1, Sxx2, 
          Syy2, Sxy2, Sxz2, Syz2, ..., Sxxn, Syyn, Sxyn, Sxzn, Syzn]</li>
        <li><strong class="pname"><code>red_data</code></strong> (numpy float64 array) - An array of the {Sxx, Syy, Sxy, Sxz, Syz} values for all reduced 
          tensors.  The format is the same as for full_tensors.</li>
        <li><strong class="pname"><code>red_errors</code></strong> (numpy float64 array) - An array of the {Sxx, Syy, Sxy, Sxz, Syz} errors for all reduced 
          tensors.  The array format is the same as for full_tensors.</li>
        <li><strong class="pname"><code>full_in_ref_frame</code></strong> (numpy rank-1 array) - An array of flags specifying if the tensor in the reference frame
          is the full or reduced tensor.</li>
        <li><strong class="pname"><code>fixed_tensors</code></strong> (list of bool) - An array of flags specifying if the tensor is fixed or will be 
          optimised.</li>
        <li><strong class="pname"><code>pcs</code></strong> (numpy rank-2 array) - The PCS lists.  The first index must correspond to the different 
          alignment media i and the second index to the spin systems j.</li>
        <li><strong class="pname"><code>pcs_errors</code></strong> (numpy rank-2 array) - The PCS error lists.  The dimensions of this argument are the 
          same as for 'pcs'.</li>
        <li><strong class="pname"><code>pcs_weights</code></strong> (numpy rank-2 array) - The PCS weight lists.  The dimensions of this argument are the 
          same as for 'pcs'.</li>
        <li><strong class="pname"><code>rdcs</code></strong> (numpy rank-2 array) - The RDC lists.  The first index must correspond to the different 
          alignment media i and the second index to the spin systems j.</li>
        <li><strong class="pname"><code>rdc_errors</code></strong> (numpy rank-2 array) - The RDC error lists.  The dimensions of this argument are the 
          same as for 'rdcs'.</li>
        <li><strong class="pname"><code>rdc_weights</code></strong> (numpy rank-2 array) - The RDC weight lists.  The dimensions of this argument are the 
          same as for 'rdcs'.</li>
        <li><strong class="pname"><code>xh_vect</code></strong> (numpy rank-2 array) - The unit XH vector lists.  The first index must correspond to the
          spin systems and the second index to each structure (its size 
          being equal to the number of states).</li>
        <li><strong class="pname"><code>temp</code></strong> (numpy rank-1 array) - The temperature of each experiment, used for the PCS.</li>
        <li><strong class="pname"><code>frq</code></strong> (numpy rank-1 array) - The frequency of each alignment, used for the PCS.</li>
        <li><strong class="pname"><code>dip_const</code></strong> (numpy rank-1 array) - The dipolar constants for each XH vector.  The indices correspond
          to the spin systems j.</li>
        <li><strong class="pname"><code>atomic_pos</code></strong> (numpy rank-3 array) - The atomic positions of all spins.  The first index is the spin 
          systems j and the second is the structure or state c.</li>
        <li><strong class="pname"><code>paramag_centre</code></strong> (numpy rank-1, 3D array or rank-2, Nx3 array) - The paramagnetic centre position (or positions).</li>
        <li><strong class="pname"><code>scaling_matrix</code></strong> (numpy rank-2 array) - The square and diagonal scaling matrix.</li>
        <li><strong class="pname"><code>centre_fixed</code></strong> (bool) - A flag which if False will cause the paramagnetic centre to be 
          optimised.</li>
    </ul></dd>
  </dl>
</td></tr></table>
</div>
<a name="func_2domain"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">func_2domain</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">params</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="maths_fns.n_state_model-pysrc.html#N_state_opt.func_2domain">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>The target function for optimisation of the 2-domain N-state 
  model.</p>
  <p>This function should be passed to the optimisation algorithm.  It 
  accepts, as an array, a vector of parameter values and, using these, 
  returns the single chi-squared value corresponding to that coordinate in 
  the parameter space.  If no tensor errors are supplied, then the SSE (the
  sum of squares error) value is returned instead.  The chi-squared is 
  simply the SSE normalised to unit variance (the SSE divided by the error 
  squared).</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>params</code></strong> (list of float) - The vector of parameter values.</li>
    </ul></dd>
    <dt>Returns: float</dt>
        <dd>The chi-squared or SSE value.</dd>
  </dl>
</td></tr></table>
</div>
<a name="func_population"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">func_population</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">params</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="maths_fns.n_state_model-pysrc.html#N_state_opt.func_population">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>The target function for optimisation of the flexible population 
  N-state model.</p>
  <h1 class="heading">Description</h1>
    <p>This function should be passed to the optimisation algorithm.  It 
    accepts, as an array, a vector of parameter values and, using these, 
    returns the single chi-squared value corresponding to that coordinate 
    in the parameter space.  If no RDC errors are supplied, then the SSE 
    (the sum of squares error) value is returned instead.  The chi-squared 
    is simply the SSE normalised to unit variance (the SSE divided by the 
    error squared).</p>
  <h1 class="heading">Indices</h1>
    <p>For this calculation, five indices are looped over and used in the 
    various data structures.  These include:</p>
    <ul>
      <li>
        i, the index over alignments,
      </li>
      <li>
        j, the index over spin systems,
      </li>
      <li>
        c, the index over the N-states (or over the structures),
      </li>
      <li>
        n, the index over the first dimension of the alignment tensor n = 
        {x, y, z},
      </li>
      <li>
        m, the index over the second dimension of the alignment tensor m = 
        {x, y, z}.
      </li>
    </ul>
  <h1 class="heading">Equations</h1>
    <p>To calculate the function value, a chain of equations are used.  
    This includes the chi-squared equation and the RDC equation.</p>
    <h2 class="heading">The chi-squared equation</h2>
      <p>The equations are:</p>
<pre class="literalblock">
                ___
                \    (Dij - Dij(theta)) ** 2
chi^2(theta)  =  &gt;   ----------------------- ,
                /__       sigma_ij ** 2
                 ij

                ___
                \    (delta_ij - delta_ij(theta)) ** 2
chi^2(theta)  =  &gt;   --------------------------------- ,
                /__             sigma_ij ** 2
                 ij
</pre>
      <p>where:</p>
      <ul>
        <li>
          theta is the parameter vector,
        </li>
        <li>
          Dij are the measured RDCs for alignment i, spin j,
        </li>
        <li>
          Dij(theta) are the back calculated RDCs for alignment i, spin j,
        </li>
        <li>
          delta_ij are the measured PCSs for alignment i, spin j,
        </li>
        <li>
          delta_ij(theta) are the back calculated PCSs for alignment i, 
          spin j,
        </li>
        <li>
          sigma_ij are the RDC or PCS errors.
        </li>
      </ul>
      <p>Both chi-squared values sum.</p>
    <h2 class="heading">The RDC equation</h2>
      <p>The RDC equation is:</p>
<pre class="literalblock">
                  _N_
                  \              T
Dij(theta)  =  dj  &gt;   pc . mu_jc . Ai . mu_jc,
                  /__
                  c=1
</pre>
      <p>where:</p>
      <ul>
        <li>
          dj is the dipolar constant for spin j,
        </li>
        <li>
          N is the total number of states or structures,
        </li>
        <li>
          pc is the weight or probability associated with state c,
        </li>
        <li>
          mu_jc is the unit vector corresponding to spin j and state c,
        </li>
        <li>
          Ai is the alignment tensor.
        </li>
      </ul>
      <p>The dipolar constant is henceforth defined as:</p>
<pre class="literalblock">
   dj = 3 / (2pi) d',
</pre>
      <p>where the factor of 2pi is to convert from units of rad.s^-1 to 
      Hertz, the factor of 3 is associated with the alignment tensor and 
      the pure dipolar constant in SI units is:</p>
<pre class="literalblock">
          mu0 gI.gS.h_bar
   d' = - --- ----------- ,
          4pi    r**3
</pre>
      <p>where:</p>
      <ul>
        <li>
          mu0 is the permeability of free space,
        </li>
        <li>
          gI and gS are the gyromagnetic ratios of the I and S spins,
        </li>
        <li>
          h_bar is Dirac's constant which is equal to Planck's constant 
          divided by 2pi,
        </li>
        <li>
          r is the distance between the two spins.
        </li>
      </ul>
    <h2 class="heading">The PCS equation</h2>
      <p>The PCS equation is:</p>
<pre class="literalblock">
                      _N_
                      \                    T
   delta_ij(theta)  =  &gt;  pc . dijc . mu_jc . Ai . mu_jc,
                      /__
                      c=1
</pre>
      <p>where:</p>
      <ul>
        <li>
          djci is the PCS constant for spin j, state c and experiment or 
          alignment i,
        </li>
        <li>
          N is the total number of states or structures,
        </li>
        <li>
          pc is the weight or probability associated with state c,
        </li>
        <li>
          mu_jc is the unit vector corresponding to spin j and state c,
        </li>
        <li>
          Ai is the alignment tensor.
        </li>
      </ul>
      <p>The PCS constant is defined as:</p>
<pre class="literalblock">
          mu0 15kT   1
   dijc = --- ----- ---- ,
          4pi Bo**2 r**3
</pre>
      <p>where:</p>
      <ul>
        <li>
          mu0 is the permeability of free space,
        </li>
        <li>
          k is Boltzmann's constant,
        </li>
        <li>
          T is the absolute temperature (different for each experiment),
        </li>
        <li>
          Bo is the magnetic field strength (different for each 
          experiment),
        </li>
        <li>
          r is the distance between the paramagnetic centre (electron spin)
          and the nuclear spin (different for each spin and state).
        </li>
      </ul>
  <h1 class="heading">Stored data structures</h1>
    <p>There are a number of data structures calculated by this function 
    and stored for subsequent use in the gradient and Hessian functions.  
    This include the back calculated RDCs and the alignment tensors.</p>
    <h2 class="heading">Dij(theta)</h2>
      <p>The back calculated RDCs.  This is a rank-2 tensor with indices 
      {i, j}.</p>
    <h2 class="heading">delta_ij(theta)</h2>
      <p>The back calculated PCS.  This is a rank-2 tensor with indices {i,
      j}.</p>
    <h2 class="heading">Ai</h2>
      <p>The alignment tensors.  This is a rank-3 tensor with indices {i, 
      n, m}.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>params</code></strong> (numpy rank-1 array) - The vector of parameter values.</li>
    </ul></dd>
    <dt>Returns: float</dt>
        <dd>The chi-squared or SSE value.</dd>
  </dl>
</td></tr></table>
</div>
<a name="func_tensor_opt"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">func_tensor_opt</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">params</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="maths_fns.n_state_model-pysrc.html#N_state_opt.func_tensor_opt">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>The target function for optimisation of the alignment tensor from RDC 
  and/or PCS data.</p>
  <h1 class="heading">Description</h1>
    <p>This function should be passed to the optimisation algorithm.  It 
    accepts, as an array, a vector of parameter values and, using these, 
    returns the single chi-squared value corresponding to that coordinate 
    in the parameter space.  If no RDC or PCS errors are supplied, then the
    SSE (the sum of squares error) value is returned instead.  The 
    chi-squared is simply the SSE normalised to unit variance (the SSE 
    divided by the error squared).</p>
  <h1 class="heading">Indices</h1>
    <p>For this calculation, five indices are looped over and used in the 
    various data structures.  These include:</p>
    <ul>
      <li>
        i, the index over alignments,
      </li>
      <li>
        j, the index over spin systems,
      </li>
      <li>
        c, the index over the N-states (or over the structures),
      </li>
      <li>
        n, the index over the first dimension of the alignment tensor n = 
        {x, y, z},
      </li>
      <li>
        m, the index over the second dimension of the alignment tensor m = 
        {x, y, z}.
      </li>
    </ul>
  <h1 class="heading">Equations</h1>
    <p>To calculate the function value, a chain of equations are used.  
    This includes the chi-squared equation and the RDC and PCS 
    equations.</p>
    <h2 class="heading">The chi-squared equation</h2>
      <p>The equations are:</p>
<pre class="literalblock">
                ___
                \    (Dij - Dij(theta)) ** 2
chi^2(theta)  =  &gt;   ----------------------- ,
                /__       sigma_ij ** 2
                 ij

                ___
                \    (delta_ij - delta_ij(theta)) ** 2
chi^2(theta)  =  &gt;   --------------------------------- ,
                /__             sigma_ij ** 2
                 ij
</pre>
      <p>where:</p>
      <ul>
        <li>
          theta is the parameter vector,
        </li>
        <li>
          Dij are the measured RDCs for alignment i, spin j,
        </li>
        <li>
          Dij(theta) are the back calculated RDCs for alignment i, spin j,
        </li>
        <li>
          delta_ij are the measured PCSs for alignment i, spin j,
        </li>
        <li>
          delta_ij(theta) are the back calculated PCSs for alignment i, 
          spin j,
        </li>
        <li>
          sigma_ij are the RDC or PCS errors.
        </li>
      </ul>
      <p>Both chi-squared values sum.</p>
    <h2 class="heading">The RDC equation</h2>
      <p>The RDC equation is:</p>
<pre class="literalblock">
                  _N_
               dj \         T
Dij(theta)  =  --  &gt;   mu_jc . Ai . mu_jc,
               N  /__
                  c=1
</pre>
      <p>where:</p>
      <ul>
        <li>
          dj is the dipolar constant for spin j,
        </li>
        <li>
          N is the total number of states or structures,
        </li>
        <li>
          mu_jc is the unit vector corresponding to spin j and state c,
        </li>
        <li>
          Ai is the alignment tensor.
        </li>
      </ul>
      <p>The dipolar constant is henceforth defined as:</p>
<pre class="literalblock">
   dj = 3 / (2pi) d',
</pre>
      <p>where the factor of 2pi is to convert from units of rad.s^-1 to 
      Hertz, the factor of 3 is associated with the alignment tensor and 
      the pure dipolar constant in SI units is:</p>
<pre class="literalblock">
          mu0 gI.gS.h_bar
   d' = - --- ----------- ,
          4pi    r**3
</pre>
      <p>where:</p>
      <ul>
        <li>
          mu0 is the permeability of free space,
        </li>
        <li>
          gI and gS are the gyromagnetic ratios of the I and S spins,
        </li>
        <li>
          h_bar is Dirac's constant which is equal to Planck's constant 
          divided by 2pi,
        </li>
        <li>
          r is the distance between the two spins.
        </li>
      </ul>
    <h2 class="heading">The PCS equation</h2>
      <p>The PCS equation is:</p>
<pre class="literalblock">
                        _N_
                      1 \               T
   delta_ij(theta)  = -  &gt;  dijc . mu_jc . Ai . mu_jc,
                      N /__
                        c=1
</pre>
      <p>where:</p>
      <ul>
        <li>
          djci is the PCS constant for spin j, state c and experiment or 
          alignment i,
        </li>
        <li>
          N is the total number of states or structures,
        </li>
        <li>
          mu_jc is the unit vector corresponding to spin j and state c,
        </li>
        <li>
          Ai is the alignment tensor.
        </li>
      </ul>
      <p>The PCS constant is defined as:</p>
<pre class="literalblock">
          mu0 15kT   1
   dijc = --- ----- ---- ,
          4pi Bo**2 r**3
</pre>
      <p>where:</p>
      <ul>
        <li>
          mu0 is the permeability of free space,
        </li>
        <li>
          k is Boltzmann's constant,
        </li>
        <li>
          T is the absolute temperature (different for each experiment),
        </li>
        <li>
          Bo is the magnetic field strength (different for each 
          experiment),
        </li>
        <li>
          r is the distance between the paramagnetic centre (electron spin)
          and the nuclear spin (different for each spin and state).
        </li>
      </ul>
  <h1 class="heading">Stored data structures</h1>
    <p>There are a number of data structures calculated by this function 
    and stored for subsequent use in the gradient and Hessian functions.  
    This include the back calculated RDCs and the alignment tensors.</p>
    <h2 class="heading">Dij(theta)</h2>
      <p>The back calculated RDCs.  This is a rank-2 tensor with indices 
      {i, j}.</p>
    <h2 class="heading">delta_ij(theta)</h2>
      <p>The back calculated PCS.  This is a rank-2 tensor with indices {i,
      j}.</p>
    <h2 class="heading">Ai</h2>
      <p>The alignment tensors.  This is a rank-3 tensor with indices {i, 
      n, m}.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>params</code></strong> (numpy rank-1 array) - The vector of parameter values.</li>
    </ul></dd>
    <dt>Returns: float</dt>
        <dd>The chi-squared or SSE value.</dd>
  </dl>
</td></tr></table>
</div>
<a name="dfunc_population"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">dfunc_population</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">params</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="maths_fns.n_state_model-pysrc.html#N_state_opt.dfunc_population">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>The gradient function for optimisation of the flexible population 
  N-state model.</p>
  <h1 class="heading">Description</h1>
    <p>This function should be passed to the optimisation algorithm.  It 
    accepts, as an array, a vector of parameter values and, using these, 
    returns the chi-squared gradient corresponding to that coordinate in 
    the parameter space.  If no RDC errors are supplied, then the SSE (the 
    sum of squares error) gradient is returned instead.  The chi-squared 
    gradient is simply the SSE gradient normalised to unit variance (the 
    SSE divided by the error squared).</p>
  <h1 class="heading">Indices</h1>
    <p>For this calculation, six indices are looped over and used in the 
    various data structures.  These include:</p>
    <ul>
      <li>
        k, the index over all parameters,
      </li>
      <li>
        i, the index over alignments,
      </li>
      <li>
        j, the index over spin systems,
      </li>
      <li>
        c, the index over the N-states (or over the structures),
      </li>
      <li>
        m, the index over the first dimension of the alignment tensor m = 
        {x, y, z}.
      </li>
      <li>
        n, the index over the second dimension of the alignment tensor n = 
        {x, y, z},
      </li>
    </ul>
  <h1 class="heading">Equations</h1>
    <p>To calculate the chi-squared gradient, a chain of equations are 
    used.  This includes the chi-squared gradient, the RDC gradient and the
    alignment tensor gradient.</p>
    <h2 class="heading">The chi-squared gradient</h2>
      <p>The equation is:</p>
<pre class="literalblock">
                     ___
dchi^2(theta)        \   / Dij - Dij(theta)     dDij(theta) \ 
-------------  =  -2  &gt;  | ----------------  .  ----------- |
   dthetak           /__ \   sigma_ij**2         dthetak    /
                     ij
</pre>
      <p>where:</p>
      <ul>
        <li>
          theta is the parameter vector,
        </li>
        <li>
          Dij are the measured RDCs or PCSs,
        </li>
        <li>
          Dij(theta) are the back calculated RDCs or PCSs,
        </li>
        <li>
          sigma_ij are the RDC or PCS errors,
        </li>
        <li>
          dDij(theta)/dthetak is the RDC or PCS gradient for parameter k.
        </li>
      </ul>
    <h2 class="heading">The RDC gradient</h2>
      <p>This gradient is different for the various parameter types.</p>
      <h3 class="heading">pc partial derivative</h3>
        <p>The population parameter partial derivative is:</p>
<pre class="literalblock">
    dDij(theta)               T
    -----------  =  dj . mu_jc . Ai . mu_jc,
        dpc
</pre>
        <p>where:</p>
        <ul>
          <li>
            dj is the dipolar constant for spin j,
          </li>
          <li>
            mu_jc is the unit vector corresponding to spin j and state c,
          </li>
          <li>
            Ai is the alignment tensor.
          </li>
        </ul>
      <h3 class="heading">Amn partial derivative</h3>
        <p>The alignment tensor element partial derivative is:</p>
<pre class="literalblock">
                   _N_
dDij(theta)        \              T   dAi
-----------  =  dj  &gt;   pc . mu_jc . ---- . mu_jc,
   dAmn            /__               dAmn
                   c=1
</pre>
        <p>where:</p>
        <ul>
          <li>
            dj is the dipolar constant for spin j,
          </li>
          <li>
            pc is the weight or probability associated with state c,
          </li>
          <li>
            mu_jc is the unit vector corresponding to spin j and state c,
          </li>
          <li>
            dAi/dAmn is the partial derivative of the alignment tensor with
            respect to element Amn.
          </li>
        </ul>
    <h2 class="heading">The PCS gradient</h2>
      <p>This gradient is also different for the various parameter 
      types.</p>
      <h3 class="heading">pc partial derivative</h3>
        <p>The population parameter partial derivative is:</p>
<pre class="literalblock">
    ddeltaij(theta)                 T
    ---------------  =  dijc . mu_jc . Ai . mu_jc,
         dpc
</pre>
        <p>where:</p>
        <ul>
          <li>
            djc is the pseudocontact shift constant for spin j and state c,
          </li>
          <li>
            mu_jc is the unit vector corresponding to spin j and state c,
          </li>
          <li>
            Ai is the alignment tensor.
          </li>
        </ul>
      <h3 class="heading">Amn partial derivative</h3>
        <p>The alignment tensor element partial derivative is:</p>
<pre class="literalblock">
                       _N_
   ddelta_ij(theta)    \                   T   dAi
   ----------------  =  &gt;  pc . djc . mu_jc . ---- . mu_jc,
         dAmn          /__                    dAmn
                       c=1
</pre>
        <p>where:</p>
        <ul>
          <li>
            djc is the pseudocontact shift constant for spin j and state c,
          </li>
          <li>
            pc is the weight or probability associated with state c,
          </li>
          <li>
            mu_jc is the unit vector corresponding to spin j and state c,
          </li>
          <li>
            dAi/dAmn is the partial derivative of the alignment tensor with
            respect to element Amn.
          </li>
        </ul>
    <h2 class="heading">The alignment tensor gradient</h2>
      <p>The five unique elements of the tensor {Axx, Ayy, Axy, Axz, Ayz} 
      give five different partial derivatives.  These are:</p>
<pre class="literalblock">
    dAi   | 1  0  0 |
   ---- = | 0  0  0 |,
   dAxx   | 0  0 -1 |

    dAi   | 0  0  0 |
   ---- = | 0  1  0 |,
   dAyy   | 0  0 -1 |

    dAi   | 0  1  0 |
   ---- = | 1  0  0 |,
   dAxy   | 0  0  0 |

    dAi   | 0  0  1 |
   ---- = | 0  0  0 |,
   dAxz   | 1  0  0 |

    dAi   | 0  0  0 |
   ---- = | 0  0  1 |.
   dAyz   | 0  1  0 |
</pre>
      <p>As these are invariant, they can be pre-calculated.</p>
  <h1 class="heading">Stored data structures</h1>
    <p>There are a number of data structures calculated by this function 
    and stored for subsequent use in the Hessian function.  This include 
    the back calculated RDC and PCS gradients and the alignment tensor 
    gradients.</p>
    <h2 class="heading">dDij(theta)/dthetak</h2>
      <p>The back calculated RDC gradient.  This is a rank-3 tensor with 
      indices {k, i, j}.</p>
    <h2 class="heading">ddeltaij(theta)/dthetak</h2>
      <p>The back calculated PCS gradient.  This is a rank-3 tensor with 
      indices {k, i, j}.</p>
    <h2 class="heading">dAi/dAmn</h2>
      <p>The alignment tensor gradients.  This is a rank-3 tensor with 
      indices {5, n, m}.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>params</code></strong> (numpy rank-1 array) - The vector of parameter values.  This is unused as it is assumed 
          that func_population() was called first.</li>
    </ul></dd>
    <dt>Returns: numpy rank-1 array</dt>
        <dd>The chi-squared or SSE gradient.</dd>
  </dl>
</td></tr></table>
</div>
<a name="dfunc_tensor_opt"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">dfunc_tensor_opt</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">params</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="maths_fns.n_state_model-pysrc.html#N_state_opt.dfunc_tensor_opt">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>The gradient function for optimisation of the alignment tensor from 
  RDC and/or PCS data.</p>
  <h1 class="heading">Description</h1>
    <p>This function should be passed to the optimisation algorithm.  It 
    accepts, as an array, a vector of parameter values and, using these, 
    returns the chi-squared gradient corresponding to that coordinate in 
    the parameter space.  If no RDC errors are supplied, then the SSE (the 
    sum of squares error) gradient is returned instead.  The chi-squared 
    gradient is simply the SSE gradient normalised to unit variance (the 
    SSE divided by the error squared).</p>
  <h1 class="heading">Indices</h1>
    <p>For this calculation, six indices are looped over and used in the 
    various data structures.  These include:</p>
    <ul>
      <li>
        k, the index over all parameters,
      </li>
      <li>
        i, the index over alignments,
      </li>
      <li>
        j, the index over spin systems,
      </li>
      <li>
        c, the index over the N-states (or over the structures),
      </li>
      <li>
        m, the index over the first dimension of the alignment tensor m = 
        {x, y, z}.
      </li>
      <li>
        n, the index over the second dimension of the alignment tensor n = 
        {x, y, z},
      </li>
    </ul>
  <h1 class="heading">Equations</h1>
    <p>To calculate the chi-squared gradient, a chain of equations are 
    used.  This includes the chi-squared gradient, the RDC gradient and the
    alignment tensor gradient.</p>
    <h2 class="heading">The chi-squared gradient</h2>
      <p>The equation is:</p>
<pre class="literalblock">
                     ___
dchi^2(theta)        \   / Dij - Dij(theta)     dDij(theta) \ 
-------------  =  -2  &gt;  | ----------------  .  ----------- |
   dthetak           /__ \   sigma_ij**2         dthetak    /
                     ij
</pre>
      <p>where:</p>
      <ul>
        <li>
          theta is the parameter vector,
        </li>
        <li>
          Dij are the measured RDCs or PCSs,
        </li>
        <li>
          Dij(theta) are the back calculated RDCs or PCSs,
        </li>
        <li>
          sigma_ij are the RDC or PCS errors,
        </li>
        <li>
          dDij(theta)/dthetak is the RDC or PCS gradient for parameter k.
        </li>
      </ul>
    <h2 class="heading">The RDC gradient</h2>
      <p>The only parameters are the tensor components.</p>
      <h3 class="heading">Amn partial derivative</h3>
        <p>The alignment tensor element partial derivative is:</p>
<pre class="literalblock">
                   _N_
dDij(theta)     dj \         T   dAi
-----------  =  --  &gt;   mu_jc . ---- . mu_jc,
   dAmn         N  /__          dAmn
                   c=1
</pre>
        <p>where:</p>
        <ul>
          <li>
            dj is the dipolar constant for spin j,
          </li>
          <li>
            N is the total number of states or structures,
          </li>
          <li>
            mu_jc is the unit vector corresponding to spin j and state c,
          </li>
          <li>
            dAi/dAmn is the partial derivative of the alignment tensor with
            respect to element Amn.
          </li>
        </ul>
    <h2 class="heading">The PCS gradient</h2>
      <h3 class="heading">Amn partial derivative</h3>
        <p>The alignment tensor element partial derivative is:</p>
<pre class="literalblock">
                         _N_
   ddelta_ij(theta)    1 \              T   dAi
   ----------------  = -  &gt;  djc . mu_jc . ---- . mu_jc,
         dAmn          N /__               dAmn
                         c=1
</pre>
        <p>where:</p>
        <ul>
          <li>
            djc is the pseudocontact shift constant for spin j and state c,
          </li>
          <li>
            N is the total number of states or structures,
          </li>
          <li>
            mu_jc is the unit vector corresponding to spin j and state c,
          </li>
          <li>
            dAi/dAmn is the partial derivative of the alignment tensor with
            respect to element Amn.
          </li>
        </ul>
    <h2 class="heading">The alignment tensor gradient</h2>
      <p>The five unique elements of the tensor {Axx, Ayy, Axy, Axz, Ayz} 
      give five different partial derivatives.  These are:</p>
<pre class="literalblock">
    dAi   | 1  0  0 |
   ---- = | 0  0  0 |,
   dAxx   | 0  0 -1 |

    dAi   | 0  0  0 |
   ---- = | 0  1  0 |,
   dAyy   | 0  0 -1 |

    dAi   | 0  1  0 |
   ---- = | 1  0  0 |,
   dAxy   | 0  0  0 |

    dAi   | 0  0  1 |
   ---- = | 0  0  0 |,
   dAxz   | 1  0  0 |

    dAi   | 0  0  0 |
   ---- = | 0  0  1 |.
   dAyz   | 0  1  0 |
</pre>
      <p>As these are invariant, they can be pre-calculated.</p>
  <h1 class="heading">Stored data structures</h1>
    <p>There are a number of data structures calculated by this function 
    and stored for subsequent use in the Hessian function.  This include 
    the back calculated RDC and PCS gradients and the alignment tensor 
    gradients.</p>
    <h2 class="heading">dDij(theta)/dthetak</h2>
      <p>The back calculated RDC gradient.  This is a rank-3 tensor with 
      indices {k, i, j}.</p>
    <h2 class="heading">ddeltaij(theta)/dthetak</h2>
      <p>The back calculated PCS gradient.  This is a rank-3 tensor with 
      indices {k, i, j}.</p>
    <h2 class="heading">dAi/dAmn</h2>
      <p>The alignment tensor gradients.  This is a rank-3 tensor with 
      indices {5, n, m}.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>params</code></strong> (numpy rank-1 array) - The vector of parameter values.  This is unused as it is assumed 
          that func_population() was called first.</li>
    </ul></dd>
    <dt>Returns: numpy rank-1 array</dt>
        <dd>The chi-squared or SSE gradient.</dd>
  </dl>
</td></tr></table>
</div>
<a name="d2func_population"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">d2func_population</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">params</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="maths_fns.n_state_model-pysrc.html#N_state_opt.d2func_population">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>The Hessian function for optimisation of the flexible population 
  N-state model.</p>
  <h1 class="heading">Description</h1>
    <p>This function should be passed to the optimisation algorithm.  It 
    accepts, as an array, a vector of parameter values and, using these, 
    returns the chi-squared Hessian corresponding to that coordinate in the
    parameter space.  If no RDC/PCS errors are supplied, then the SSE (the 
    sum of squares error) Hessian is returned instead.  The chi-squared 
    Hessian is simply the SSE Hessian normalised to unit variance (the SSE 
    divided by the error squared).</p>
  <h1 class="heading">Indices</h1>
    <p>For this calculation, six indices are looped over and used in the 
    various data structures.  These include:</p>
    <ul>
      <li>
        k, the index over all parameters,
      </li>
      <li>
        i, the index over alignments,
      </li>
      <li>
        j, the index over spin systems,
      </li>
      <li>
        c, the index over the N-states (or over the structures),
      </li>
      <li>
        m, the index over the first dimension of the alignment tensor m = 
        {x, y, z}.
      </li>
      <li>
        n, the index over the second dimension of the alignment tensor n = 
        {x, y, z},
      </li>
    </ul>
  <h1 class="heading">Equations</h1>
    <p>To calculate the chi-squared gradient, a chain of equations are 
    used.  This includes the chi-squared gradient, the RDC gradient and the
    alignment tensor gradient.</p>
    <h2 class="heading">The chi-squared Hessian</h2>
      <p>The equation is:</p>
<pre class="literalblock">
                      ___
d2chi^2(theta)        \       1      / dDij(theta)   dDij(theta)                         d2Dij(theta)   \ 
---------------  =  2  &gt;  ---------- | ----------- . -----------  -  (Dij-Dij(theta)) . --------------- |.
dthetaj.dthetak       /__ sigma_i**2 \  dthetaj       dthetak                           dthetaj.dthetak /
                      ij
</pre>
      <p>where:</p>
      <ul>
        <li>
          theta is the parameter vector,
        </li>
        <li>
          Dij are the measured RDCs or PCSs,
        </li>
        <li>
          Dij(theta) are the back calculated RDCs or PCSs,
        </li>
        <li>
          sigma_ij are the RDC or PCS errors,
        </li>
        <li>
          dDij(theta)/dthetak is the RDC or PCS gradient for parameter k.
        </li>
        <li>
          d2Dij(theta)/dthetaj.dthetak is the RDC or PCS Hessian for 
          parameters j and k.
        </li>
      </ul>
    <h2 class="heading">The RDC Hessian</h2>
      <h3 class="heading">pc-pd second partial derivatives</h3>
        <p>The probability parameter second partial derivative is:</p>
<pre class="literalblock">
d2Dij(theta)
------------  =  0.
  dpc.dpd
</pre>
      <h3 class="heading">pc-Anm second partial derivatives</h3>
        <p>The probability parameter-tensor element second partial 
        derivative is:</p>
<pre class="literalblock">
d2Dij(theta)               T   dAi
------------  =  dj . mu_jc . ---- . mu_jc.
  dpc.dAmn                    dAmn
</pre>
      <h3 class="heading">Amn-Aop second partial derivatives</h3>
        <p>The alignment tensor element second partial derivative is:</p>
<pre class="literalblock">
d2Dij(theta)
------------  =  0.
 dAmn.dAop
</pre>
    <h2 class="heading">The PCS Hessian</h2>
      <h3 class="heading">pc-pd second partial derivatives</h3>
        <p>The probability parameter second partial derivative is:</p>
<pre class="literalblock">
d2delta_ij(theta)
-----------------  =  0.
     dpc.dpd
</pre>
      <h3 class="heading">pc-Anm second partial derivatives</h3>
        <p>The probability parameter-tensor element second partial 
        derivative is:</p>
<pre class="literalblock">
d2delta_ij(theta)                T   dAi
-----------------  =  djc . mu_jc . ---- . mu_jc.
    dpc.dAmn                        dAmn
</pre>
      <h3 class="heading">Amn-Aop second partial derivatives</h3>
        <p>The alignment tensor element second partial derivative is:</p>
<pre class="literalblock">
   d2delta_ij(theta)
   -----------------  =  0
       dAmn.dAop
</pre>
    <h2 class="heading">The alignment tensor Hessian</h2>
      <p>The five unique elements of the tensor {Axx, Ayy, Axy, Axz, Ayz} 
      all have the same second partial derivative of:</p>
<pre class="literalblock">
     d2Ai      | 0  0  0 |
   --------- = | 0  0  0 |.
   dAmn.dAop   | 0  0  0 |
</pre>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>params</code></strong> (numpy rank-1 array) - The vector of parameter values.  This is unused as it is assumed 
          that func_population() was called first.</li>
    </ul></dd>
    <dt>Returns: numpy rank-2 array</dt>
        <dd>The chi-squared or SSE Hessian.</dd>
  </dl>
</td></tr></table>
</div>
<a name="d2func_tensor_opt"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">d2func_tensor_opt</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">params</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="maths_fns.n_state_model-pysrc.html#N_state_opt.d2func_tensor_opt">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>The Hessian function for optimisation of the alignment tensor from RDC
  and/or PCS data.</p>
  <h1 class="heading">Description</h1>
    <p>This function should be passed to the optimisation algorithm.  It 
    accepts, as an array, a vector of parameter values and, using these, 
    returns the chi-squared Hessian corresponding to that coordinate in the
    parameter space.  If no RDC/PCS errors are supplied, then the SSE (the 
    sum of squares error) Hessian is returned instead.  The chi-squared 
    Hessian is simply the SSE Hessian normalised to unit variance (the SSE 
    divided by the error squared).</p>
  <h1 class="heading">Indices</h1>
    <p>For this calculation, six indices are looped over and used in the 
    various data structures.  These include:</p>
    <ul>
      <li>
        k, the index over all parameters,
      </li>
      <li>
        i, the index over alignments,
      </li>
      <li>
        j, the index over spin systems,
      </li>
      <li>
        c, the index over the N-states (or over the structures),
      </li>
      <li>
        m, the index over the first dimension of the alignment tensor m = 
        {x, y, z}.
      </li>
      <li>
        n, the index over the second dimension of the alignment tensor n = 
        {x, y, z},
      </li>
    </ul>
  <h1 class="heading">Equations</h1>
    <p>To calculate the chi-squared gradient, a chain of equations are 
    used.  This includes the chi-squared gradient, the RDC gradient and the
    alignment tensor gradient.</p>
    <h2 class="heading">The chi-squared Hessian</h2>
      <p>The equation is:</p>
<pre class="literalblock">
                      ___
d2chi^2(theta)        \       1      / dDij(theta)   dDij(theta)                         d2Dij(theta)   \ 
---------------  =  2  &gt;  ---------- | ----------- . -----------  -  (Dij-Dij(theta)) . --------------- |.
dthetaj.dthetak       /__ sigma_i**2 \  dthetaj       dthetak                           dthetaj.dthetak /
                      ij
</pre>
      <p>where:</p>
      <ul>
        <li>
          theta is the parameter vector,
        </li>
        <li>
          Dij are the measured RDCs or PCSs,
        </li>
        <li>
          Dij(theta) are the back calculated RDCs or PCSs,
        </li>
        <li>
          sigma_ij are the RDC or PCS errors,
        </li>
        <li>
          dDij(theta)/dthetak is the RDC or PCS gradient for parameter k.
        </li>
        <li>
          d2Dij(theta)/dthetaj.dthetak is the RDC or PCS Hessian for 
          parameters j and k.
        </li>
      </ul>
    <h2 class="heading">The RDC Hessian</h2>
      <p>The only parameters are the tensor components.</p>
      <h3 class="heading">Amn-Aop second partial derivatives</h3>
        <p>The alignment tensor element second partial derivative is:</p>
<pre class="literalblock">
d2Dij(theta)
------------  =  0.
 dAmn.dAop
</pre>
    <h2 class="heading">The PCS Hessian</h2>
      <h3 class="heading">Amn-Aop second partial derivatives</h3>
        <p>The alignment tensor element second partial derivative is:</p>
<pre class="literalblock">
   d2delta_ij(theta)
   -----------------  =  0
       dAmn.dAop
</pre>
    <h2 class="heading">The alignment tensor Hessian</h2>
      <p>The five unique elements of the tensor {Axx, Ayy, Axy, Axz, Ayz} 
      all have the same second partial derivative of:</p>
<pre class="literalblock">
     d2Ai      | 0  0  0 |
   --------- = | 0  0  0 |.
   dAmn.dAop   | 0  0  0 |
</pre>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>params</code></strong> (numpy rank-1 array) - The vector of parameter values.  This is unused as it is assumed 
          that func_population() was called first.</li>
    </ul></dd>
    <dt>Returns: numpy rank-2 array</dt>
        <dd>The chi-squared or SSE Hessian.</dd>
  </dl>
</td></tr></table>
</div>
<br />
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Project homepage -->
      <th class="navbar" align="right" width="100%">
        <table border="0" cellpadding="0" cellspacing="0">
          <tr><th class="navbar" align="center"
            ><a class="navbar" target="_top" href="http://www.nmr-relax.com">relax</a></th>
          </tr></table></th>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0" width="100%%">
  <tr>
    <td align="left" class="footer">
    Generated by Epydoc 3.0.1 on Wed Apr 10 13:31:45 2013
    </td>
    <td align="right" class="footer">
      <a target="mainFrame" href="http://epydoc.sourceforge.net"
        >http://epydoc.sourceforge.net</a>
    </td>
  </tr>
</table>

<script type="text/javascript">
  <!--
  // Private objects are initially displayed (because if
  // javascript is turned off then we want them to be
  // visible); but by default, we want to hide them.  So hide
  // them unless we have a cookie that says to show them.
  checkCookie();
  // -->
</script>
</body>
</html>
