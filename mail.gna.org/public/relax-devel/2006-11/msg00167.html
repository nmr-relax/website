<!-- MHonArc v2.6.10 -->
<!--X-Subject: Re: Re(2): r2801 &#45; /branches/test_suite/float.py -->
<!--X-From-R13: "Sqjneq q'Ohiretar" <rqjneq.qnhiretarNtznvy.pbz> -->
<!--X-Date: Sun, 19 Nov 2006 05:39:47 +0100 -->
<!--X-Message-Id: 7f080ed10611182039g2ab8be78uc8cdc7736afc7df4@mail.gmail.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: f001463a0611150313r32db2d84na26b6acfd658b0a0@mail.gmail.com -->
<!--X-Head-End-->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: Re(2): r2801 - /branches/test_suite/float.py -- November 19, 2006 - 05:39</title>
<link rel="stylesheet" type="text/css" href="/mail.gna.org/archives-color-gna.css"> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<h2><img src="/mail.gna.org/images/mail.orig.png" width="48" height="48"
alt="mail" class="pageicon" />Re: Re(2): r2801 - /branches/test_suite/float.py</h2>
<br />
<div class="topmenu">
<a href="../" class="tabs">Others Months</a> | <a href="index.html#00167" class="tabs">Index by Date</a> | <a href="threads.html#00167" class="tabs">Thread Index</a><br />
<span class="smaller">&gt;&gt;&nbsp;&nbsp;
[<a href="msg00166.html">Date Prev</a>] [<a href="msg00168.html">Date Next</a>] [<a href="msg00162.html">Thread Prev</a>] [<a href="msg00168.html">Thread Next</a>]
</div>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h3><a name="header" href="#header">Header</a></h3>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul class="headdata">
<li class="menuitem">
<em>To</em>: &quot;gary thompson&quot; &lt;garyt@xxxxxxxxxxxxxxx&gt;</li>
<li class="menuitem">
<em>Date</em>: Sun, 19 Nov 2006 15:39:09 +1100</li>
<li class="menuitem">
<em>Cc</em>: relax-devel@xxxxxxx</li>
<li class="menuitem">
<em>Message-id</em>: &lt;<a href="msg00167.html">7f080ed10611182039g2ab8be78uc8cdc7736afc7df4@mail.gmail.com</a>&gt;</li>
<li class="menuitem">
<em>References</em>: &lt;<a href="msg00162.html">f001463a0611150313r32db2d84na26b6acfd658b0a0@mail.gmail.com</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
</div><!-- end headdata -->
<br />
<h3><a name="content" href="#content">Content</a></h3>
<div class="postedby">Posted by <strong>Edward d'Auvergne</strong> on November 19, 2006 - 05:39:</div>
<div class="msgdata">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<tt>On 11/15/06, gary thompson &lt;garyt@xxxxxxxxxxxxxxx&gt; wrote:
</tt><blockquote class="blockquote"><pre style="margin: 0em;">&gt; edward.dauvergne@xxxxxxxxx wrote:
&gt;
&gt;  &gt;Author: bugman
&gt; &gt;Date: Sat Nov 11 10:57:35 2006
&gt; &gt;New Revision: 2801
&gt; &gt;
&gt; &gt;URL: <a  href="http://svn.gna.org/viewcvs/relax?rev=2801&amp;view=rev">http://svn.gna.org/viewcvs/relax?rev=2801&amp;view=rev</a>
&gt; &gt;Log:
&gt; &gt;Two functions for converting a string bit pattern to a float and a number 
of
&gt; IEEE-754 constants.
&gt; &gt;
&gt; &gt;The fucntions 'bitpatternToFloat()' and 'bitpatternToInt()' have been added
&gt; to 'float.py'.  The
&gt; &gt;first converts a 64 bit IEEE-754 bit pattern in the form of a string into a
&gt; 64 bit Python float.
&gt; &gt;The second converts an arbitrary bit pattern into its integer
&gt; representation.  By looping over each
&gt; &gt;8 characters of the string (1 byte), 'bitpatternToFloat()' calls
&gt; 'bitpatternToInt()' to create an
&gt; &gt;array of integers.  Then 'packBytesAsPyFloat()' is called to convert the
&gt; byte array into the float.
&gt; &gt;These two functions convert between big and little endian when necessary.
&gt; &gt;
&gt; &gt;
&gt; Nice functions! However, I would suggest that these should go in utility
&gt; functions or  the test suite.... I am trying to keep float.py as the
&gt; bare minimum file for testing floating point numbers and floating point
&gt; constants
&gt;
&gt;
&gt; I agree - these string to float conversions are auxiliary to intended
&gt; purpose of the IEEE-754 module.  Unfortunately as you hadn't committed
&gt; the utility function code yet - I wasn't able to put the functions
&gt; there :).
&gt;
&gt; This is true but certainly at this stage the product is just too half cut 
for
 anyone else and I wanted to concentrate on the primary problem (i.e. 
float.py)
 and complete that first unit, test it etc before I did some work on
the capabilities
</pre></blockquote><pre style="margin: 0em;"><br>Maybe it's time to soon merge the 'test_suite' branch (once the first
unit tests are running).  The integration of the unit tests and
systems tests into a modified test suite framework could be done
within the main 1.3 line.  Then you could create a new private branch
from the 1.3 line for all the rough floating point code you are
working on.  You could then work on this branch while others work on
the data model redesign.  As the floating point code won't be affected
by the data model redesign, merging changes would be trivial.  If you
want to see some really half cut code, look at the history of the
'tensor_pdb' branch.  In a large number of revisions, relax wouldn't
even run!</pre><br>
<br>
<blockquote class="blockquote"><pre style="margin: 0em;">&gt;  How would you like to design the ieee754 module?  Have you searched
&gt; for documentation describing how to create standard Python modules,
&gt; i.e. the format and structure of the modules?  Should the utility
&gt; functions be part of the module?  Or should the be their own module?</pre><br>
<pre style="margin: 0em;">Something I have to thing about and read python in a nutshell. basically if 
the
 utility functions are private they shouldn't be part of the public interface.
 Otherwise it is just a question of keeping the utility of the module 
focused...
</pre></blockquote><pre style="margin: 0em;"><br>Would a user ever find these functions useful though?</pre><br>
<br>
<blockquote class="blockquote"><pre style="margin: 0em;">&gt; The 'bitpatternToFloat()' function I added is 100% specific to
&gt; IEEE-754 though.  Do you think it would be a good idea, for future
&gt; Python inclusion and to improve on 'fpconst', to create a module which
&gt; includes as many IEEE-754 related functions as possible?
&gt;
&gt;
I would try to keep the number of functions to the minimum and maintain 
fpconst
compatabilty. all other functions can go in separate modules if needed.
</pre></blockquote><pre style="margin: 0em;"><br>Although using hex internally is good, would it not be useful for a
user unfamiliar with hex to have access to a set of functions which
convert bit pattern strings into the corresponding floating point
number and vice versa?  In addition inputting hex and hex strings (eg
'FFFFFFFF') to get the floating point number and vice versa?</pre><br>
<pre style="margin: 0em;">Again I think that functions a user would find useful should be
accessible to the user.  All the other functions can be hidden.  Have
you had a look at Distutils?  I would assume that turning the ieee754
code into site-packages using Distutils would be an important step in
the process of getting this into Python.</pre><br>
<br>
<blockquote class="blockquote"><pre style="margin: 0em;">&gt; A couple of other matters as well
&gt;
&gt;  1. the constants are not much use at the end of the file as if anything
&gt; else in the file wants to refer to them they won't be able to
</pre></blockquote><pre style="margin: 0em;"><br>At the moment, the 'float.py' file is very difficult to navigate due
to the seemingly random ordering of the functions and constants.
Would it be OK to bring some order into this code?  Could the
functions be sorted alphabetically?</pre><br>
<pre style="margin: 0em;">And where would constants go?  I think the end is perfectly ok as
these are intended for the user (and possibly unit tests) and none of
the functions in 'float.py' use them (including the 'nan', 'pos_inf',
'neg_inf', 'NAN_BYTES', and 'INF_BYTES' you have defined in the
middle).  The other point is that to generate the constants, calls to
functions in 'float.py' are required and hence these functions must be
located above the constants.</pre><br>
<pre style="margin: 0em;">I think we should implement all the constants in the '64-bit Double
Precision' table located at
<a  href="http://babbage.cs.qc.edu/courses/cs341/IEEE-754references.html">http://babbage.cs.qc.edu/courses/cs341/IEEE-754references.html</a>.  This
would be about 5 min worth of work.  They could use
'bitpatternToFloat()', although ideally they should use
'packBytesAsPyFloat()'.  They should each have a docstring describing
what the constant is.  In that docstring there should be the
bitpattern (probably in big endian), and the hexadecimal
representation.  For the IEEE-754 numbers with ranges we could have
Max and Min versions to delimit the range.  Hence we could have the
following constants (in big endian hex):</pre><br>
<pre style="margin: 0em;">NegQuiteNaNMin = 'FFFFFFFFFFFFFFFF'
NegQuiteNaNMax = 'FFF8000000000001'
NegQuiteNaN = NegQuiteNaNMin
Indeterminate = 'FFF8000000000000'
NegSigNaNMin = 'FFF7FFFFFFFFFFFF'
NegSigNaNMax = 'FFF0000000000001'
NegSigNaN = NegSigNaNMin
NegInf = 'FFF0000000000000'
NegNormMin = 'FFEFFFFFFFFFFFFF'
NegNormMax = '8010000000000000'
NegEpsilonNorm = NegNormMax
NegMin = NegNormMin
NegDenormMin = '800FFFFFFFFFFFFF'
NegDenormMax = '8000000000000001'
NegEpsilonDenorm = NegDenormMax
NegZero = '8000000000000000'
NegUnderflow = NegZero
PosZero = '0000000000000000'
PosUnderflow = PosZero
PosDenormMin = '0000000000000001'
PosDenormMax = '000FFFFFFFFFFFFF'
PosEpsilonDenorm = PosDenormMin
PosNormMin = '0010000000000000'
PosNormMax = '7FEFFFFFFFFFFFFF'
PosEpsilonNorm = PosNormMin
PosMax = PosNormMax
PosInf = '7FF0000000000000'
PosSigNaNMin = '7FF0000000000001'
PosSigNaNMax = '7FF7FFFFFFFFFFFF'
PosSigNaN = PosSigNaNMin
PosQuiteNaNMin = '7FF8000000000000'
PosQuiteNaNMax = '7FFFFFFFFFFFFFFF'
PosQuiteNaN = PosQuiteNaNMin</pre><br>
<br>
<blockquote class="blockquote"><pre style="margin: 0em;">&gt; I didn't expect anything in 'float.py' to use them.  I just expanded
&gt; the constants proposed in PEP-754
&gt; (<a  href="http://www.python.org/dev/peps/pep-0754/">http://www.python.org/dev/peps/pep-0754/</a>) into a complete list of all
&gt; the IEEE-754 special numbers.  That was pretty simple to do.  They can
&gt; be imported into the unit tests as an accurate replacement for
&gt; FLOAT_EPSILON, etc.  Their main usage would be by the users of the
&gt; module.
&gt;</pre><br>
<pre style="margin: 0em;">fair enough still the top is the place to put them (this is also where users
would expect to search for constants...)
</pre></blockquote><pre style="margin: 0em;"><br>This isn't possible as they call functions in 'float.py'.  Hence I
think the bottom would be better as they wouldn't then break up the
order of the functions.  All the stuff like 'MANTISSA_NIBBLE_MASK'
etc. which will need to be later hidden from the user could be located
at the start (or possibly in another user non-accessible module).</pre><br>
<br>
<blockquote class="blockquote"><pre style="margin: 0em;">The three NaN just give the users of the module a
&gt; few different NaN numbers to play with.  I can't stand the way I've
&gt; named them though!
&gt;</pre><br>
<pre style="margin: 0em;">I would suggest that we don't want to have multiple nans. decide on one good 
bit
pattern that is easy to identify and then use it everywhere.
This will make debugging a lost easier. One suggestion is to have a
memorable hex
pattern e.g. 'deadara' or something similar
</pre></blockquote><pre style="margin: 0em;"><br>The constants above borrowed from
<a  href="http://babbage.cs.qc.edu/courses/cs341/IEEE-754references.html">http://babbage.cs.qc.edu/courses/cs341/IEEE-754references.html</a> have
multiple NaNs (quite, signalling, neg, pos, min, max, etc.).  The ones
I've added can be deleted or moved to the unit tests.</pre><br>
<br>
<blockquote class="blockquote"><pre style="margin: 0em;">as an aside from my (limited) reading of the ieee spec it seems that
the extra patterns
are just there to give the designers of fpus some flexibility</pre><br>
<pre style="margin: 0em;">now when we come round to unit testing thats a different matter here we want
lots of nans and if the names are ugly who cares as long as they don't change!
</pre></blockquote><pre style="margin: 0em;"><br>I'll respond to the rest in a second post.</pre><br>
<pre style="margin: 0em;">Cheers,</pre><br>
<pre style="margin: 0em;">Edward</pre><br>
<br>

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div><!-- end msgdata -->
<br />
<h3><a name="related" href="#related">Related Messages</a></h3>
<div class="relateddata">
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00162" href="msg00162.html">Re(2): r2801 - /branches/test_suite/float.py</a></strong>
<ul><li><em>From:</em> gary thompson</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
</div><!-- end relateddata -->
<!-- NoBotLinksApartFromRelatedMessages -->

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
<div class="footer"></div><br />
<div class="right">Powered by <a href="http://www.mhonarc.org">MHonArc</a>, Updated Sun Nov 19 06:20:33 2006</div>  
</body>
</html>
