<!-- MHonArc v2.6.10 -->
<!--X-Subject: Re: Redesign of the relax data model: 3. Molecules, residues,	and spins -->
<!--X-From-R13: Quevf [npDnvyq <p.n.znpenvyqNyrrqf.np.hx> -->
<!--X-Date: Mon, 15 Jan 2007 18:55:56 +0100 -->
<!--X-Message-Id: 1168883717.7569.511.camel@mrspell -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: f001463a0701071417w6bd7927cp8fdd052e698575ec@mail.gmail.com -->
<!--X-Reference: 1168433714.7569.359.camel@mrspell -->
<!--X-Reference: 7f080ed10701150145q53b01785ucc3b04a3a61fdc07@mail.gmail.com -->
<!--X-Head-End-->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: Redesign of the relax data model: 3. Molecules, residues,	and spins -- January 15, 2007 - 18:55</title>
<link rel="stylesheet" type="text/css" href="/archives-color-gna.css"> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<h2><img src="https://gna.org/images/gna.theme/mail.orig.png" width="48" height="48"
alt="mail" class="pageicon" />Re: Redesign of the relax data model: 3. Molecules, residues,	and spins</h2>
<br />
<div class="topmenu">
<a href="../" class="tabs">Others Months</a> | <a href="index.html#00036" class="tabs">Index by Date</a> | <a href="threads.html#00036" class="tabs">Thread Index</a><br />
<span class="smaller">&gt;&gt;&nbsp;&nbsp;
[<a href="msg00035.html">Date Prev</a>] [<a href="msg00037.html">Date Next</a>] [<a href="msg00032.html">Thread Prev</a>] [<a href="msg00040.html">Thread Next</a>]
</div>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h3><a name="header" href="#header">Header</a></h3>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul class="headdata">
<li class="menuitem">
<em>To</em>: Edward d'Auvergne &lt;edward.dauvergne@xxxxxxxxx&gt;</li>
<li class="menuitem">
<em>Date</em>: Mon, 15 Jan 2007 17:55:17 +0000</li>
<li class="menuitem">
<em>Cc</em>: relax-devel@xxxxxxx</li>
<li class="menuitem">
<em>Message-id</em>: &lt;<a href="msg00036.html">1168883717.7569.511.camel@mrspell</a>&gt;</li>
<li class="menuitem">
<em>References</em>: &lt;<a href="msg00014.html">f001463a0701071417w6bd7927cp8fdd052e698575ec@mail.gmail.com</a>&gt;	&lt;<a href="msg00021.html">1168433714.7569.359.camel@mrspell</a>&gt;	&lt;<a href="msg00032.html">7f080ed10701150145q53b01785ucc3b04a3a61fdc07@mail.gmail.com</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
</div><!-- end headdata -->
<br />
<h3><a name="content" href="#content">Content</a></h3>
<div class="postedby">Posted by <strong>Chris MacRaild</strong> on January 15, 2007 - 18:55:</div>
<div class="msgdata">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre style="margin: 0em;">On Mon, 2007-01-15 at 20:45 +1100, Edward d'Auvergne wrote:
</pre><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><blockquote class="blockquote"><pre style="margin: 0em;">  It will be up to the spin-specific function passed in by the calling
  function to handle the 'spin.select' value.  Because of the 
complexity
  of the loop, the use of this single 'spin_loop()' function will 
simplify
  the relax code base, will minimise potential bugs, and will simplify
  future changes to the relax data model (if necessary).
</pre></blockquote><pre style="margin: 0em;">

use of an iterator object will provide flexibility as iterators can be
wrapped filtered and generally mucked about with using pythons loops
and iter tools. Whats more they are  doddle to code as all you do is
write an ordinary function and call yield with a value each time you
have  identified a selected spin
(<a  href="http://www.python.org/dev/peps/pep-0255/">http://www.python.org/dev/peps/pep-0255/</a>).... This also allows
arbitrary selection to be added as wrapper iterators or filtered
iterators

</pre></blockquote><pre style="margin: 0em;">

The UCSF selection syntax is sufficiently powerful for all relax needs,
as well as being simple and well known amongst potential users. It seems
like an excellent alternative to the current spin selection methods.
Coding the parser as an iterator is also a good idea.
</pre></blockquote><pre style="margin: 0em;">

Agreed.  Before we go down the path of the Molmol/UCSF syntax, is
there another more intuitive syntax used by other NMR software?


</pre><blockquote class="blockquote"><pre style="margin: 0em;">To extend things a bit further, we could incorporate all of this with a
functor similar to that proposed for handling multiple run selections
(<a  href="https://mail.gna.org/public/relax-devel/2007-01/msg00013.html">https://mail.gna.org/public/relax-devel/2007-01/msg00013.html</a> and
<a  href="https://mail.gna.org/public/relax-devel/2007-01/msg00020.html">https://mail.gna.org/public/relax-devel/2007-01/msg00020.html</a> ). Of
course the spin functor would opperate at a different level of code to
the run functor - whereas all user functions would be instances of the
run functor, only certain internal functions (those that act on a single
spin) would be instances of the spin functor.
</pre></blockquote><pre style="margin: 0em;">

The user functions are instances of the run functor?  Do you mean the
functions called by the user functions are instances?
</pre></blockquote><pre style="margin: 0em;">

No. In my interpretation of Gary's initial suggestion (gary:
<a  href="https://mail.gna.org/public/relax-devel/2007-01/msg00013.html">https://mail.gna.org/public/relax-devel/2007-01/msg00013.html</a> and me:
<a  href="https://mail.gna.org/public/relax-devel/2007-01/msg00020.html">https://mail.gna.org/public/relax-devel/2007-01/msg00020.html</a> ), each
relax user command is an instance of a functor which catches the runs
argument if passed, impliments the run loop (or run stack in Gary's
implimentation), and calls the relevant function in prompt/

Then all internal relax functions act only on the current run.

Because spin selection is used differently by different relax functions,
and because there is no concept of a 'current spin', my suggestion of a
spin functor lacks the generality and elegance of Gary's idea, but it
might still be worth considering for its code simplification potential.
There are plenty of functions in relax that opperate on a single spin,
and there will be plenty of occasions where we need to code something
like:

for spin in spin_loop(selection):
    do_something(spin)

The spin functor idea is simply that this code can be replaced with:

do_something(selection)

where the 'function' do_something is in fact an instance of the spin
functor:

class Spin_command():
    def __init__(self, function):
        self.function = function
    def __call__(self, *args, **kwds):
        if 'selection' in kwds.keys():
            selection = kwds['selection']
            del kwds['selection']
            for spin in spin_loop(selection):
                args.insert(0, spin)
                # or kwds['spin'] = spin
                # depending on the agreed syntax of function
                self.function(*args, **kwds)

The gain in simplicity is arguably marginal, but there will be a lot of
examples where it might apply.

</pre><blockquote class="blockquote"><pre style="margin: 0em;">

The spin selection itself is used quite differently by different parts
of the code base and I'm not sure if implementing the parser as a
generator is a good idea.  For example the selection string could be
passed to the spin loop function which is a generator yielding  the
spin system data container.  Using Gary's spin system selection and
generator ideas
(<a  href="https://mail.gna.org/public/relax-devel/2007-01/msg00014.html">https://mail.gna.org/public/relax-devel/2007-01/msg00014.html</a>,
Message-id: &lt;f001463a0701071417w6bd7927cp8fdd052e698575ec@xxxxxxxxxxxxxx&gt;),
the spin loop presented at
<a  href="https://mail.gna.org/public/relax-devel/2006-10/msg00057.html">https://mail.gna.org/public/relax-devel/2006-10/msg00057.html</a>
(Message-id: 
&lt;1160557041.9523.74.camel@xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&gt;)
would be simple.  One argument goes into the function, the selection
string, and the final line would be a yield statement.  In this spin
loop example, maybe it would be useful to have separate
generators/iterators for the molecules, residues, and atoms.  Then the
spin loop could become:

    def spin_loop(selection=None):
        &quot;&quot;&quot;Function for selectively looping over all spins.&quot;&quot;&quot;

        # Reassign the data container.
        data = self.relax.data[self.relax.run]

        # Loop over the molecules.
        for mol in data.mol:
            # Skip the molecule if there is no match to the selection.
            skip = 1
            for mol_name in mol_iterator(selection):
                if mol_name == mol.name:
                    skip = 0
            if skip:
                continue

            # Loop over the residues.
            for res in mol.res:
                # Skip the residue if there is no match to the selection.
                skip = 1
                for res_num, res_name in res_iterator(selection):
                    if res_num == res.num and res_name == res.name:
                        skip = 0
                if skip:
                    continue

                # Loop over the spins.
                for spin in res.spin:
                    # Skip the spin if there is no match to the selection.
                    skip = 1
                    for atom_num, atom_name in atom_iterator(selection):
                        if atom_num == spin.num and atom_name == spin.name:
                            skip = 0
                    if skip:
                        continue

                    # Yield the spin system data container.
                    yield spin


This setup could possibly be more numerically efficient than say:

    def spin_loop(selection=None):
        &quot;&quot;&quot;Function for selectively looping over all spins.&quot;&quot;&quot;

        # Reassign the data container.
        data = self.relax.data[self.relax.run]

        # Loop over the molecules.
        for mol in data.mol:
            # Loop over the residues.
            for res in mol.res:
                # Loop over the spins.
                for spin in res.spin:
                    # Skip the spin if there is no match to the selection.
                    skip = 1
                    for mol_name, res_num, res_name, atom_num,
atom_name in atom_iterator(selection):
                        if mol_name == mol.name and res_num == res.num
and res_name == res.name and atom_num == spin.num and atom_name ==
spin.name:
                            skip = 0
                    if skip:
                        continue

                    # Yield the spin system data container.
                    yield spin


However rather than using a generator for the selection, maybe the
function 'is_selected' could be created:

    def spin_loop(selection=None):
        &quot;&quot;&quot;Function for selectively looping over all spins.&quot;&quot;&quot;

        # Reassign the data container.
        data = self.relax.data[self.relax.run]

        # Loop over the molecules.
        for mol in data.mol:
            # Loop over the residues.
            for res in mol.res:
                # Loop over the spins.
                for spin in res.spin:
                    # Skip the spin if there is no match to the selection.
                    if not is_selected(selection, mol.name, res.num,
res.name, spin.num, spin.name):
                        continue

                    # Yield the spin system data container.
                    yield spin


</pre></blockquote><pre style="margin: 0em;">

This last example seems to be the simplest and most efficient code.
However I think yet another possibility might be better here. Rather
that looping over all molecules, residues and spins in the data in order
to find a selection that might be only a tiny subset of that, why not
loop over the selection, then ask whether each selection makes sense in
terms of the data? This will be the most efficient approach as long as
data &gt; selection, which is likely to be the most common situation.

Assuming we are using a UCSF-like selection syntax, we might code this
like:

spin_loop(selection):
    mol_token, res_token, spin_token = tokenise(selection)
    if mol_token == None:
        mol_token = data.mol
    if res_token == None:
        res_token = data.res
    if spin_token == None
        spin_token = data.spin
    for mol in parse_token(mol_token):
        if not mol in data.mol:
            continue
        for res in parse_token(res_token):
            if not res in data.res:
               continue
            for spin in parse_token(spin_token):
                if not spin in data.spin:
                    continue
                yeild spin

the functions tokenise and parse_token do the work of parsing the
selection. tokenise will split on the mol, res, spin identifiers ('#',
':', '@' in UCSF-speek), returning None for tokens without identifiers.
parse_token will interpret a string like &quot;2,4,6-10&quot;, returning a list
[2,4,6,7,8,9,10] (or the equivalent iterator if that is desirable). 

I coded these functions a while ago for another purpose, so I could dig
them out if necessary.


</pre><blockquote class="blockquote"><pre style="margin: 0em;">Edward

</pre></blockquote><pre style="margin: 0em;">



</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div><!-- end msgdata -->
<br />
<h3><a name="related" href="#related">Related Messages</a></h3>
<div class="relateddata">
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00041" href="msg00041.html">Re: Redesign of the relax data model: 3. Molecules, residues,	and spins</a></strong>
<ul><li><em>From:</em> Edward d'Auvergne</li></ul></li>
<li><strong><a name="00040" href="msg00040.html">Re: Redesign of the relax data model: 3. Molecules, residues,	and spins</a></strong>
<ul><li><em>From:</em> Edward d'Auvergne</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00014" href="msg00014.html">re: Redesign of the relax data model: 3. Molecules, residues,	and spins</a></strong>
<ul><li><em>From:</em> gary thompson</li></ul></li>
<li><strong><a name="00021" href="msg00021.html">re: Redesign of the relax data model: 3. Molecules, residues,	and spins</a></strong>
<ul><li><em>From:</em> Chris MacRaild</li></ul></li>
<li><strong><a name="00032" href="msg00032.html">Re: Redesign of the relax data model: 3. Molecules, residues,	and spins</a></strong>
<ul><li><em>From:</em> Edward d'Auvergne</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
</div><!-- end relateddata -->
<!-- NoBotLinksApartFromRelatedMessages -->

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
<div class="footer">You are on the <a href="http://gna.org">Gna!</a> mail server.</div><br />
<div class="right">Powered by <a href="http://www.mhonarc.org">MHonArc</a>, Updated Fri Jan 19 13:20:19 2007</div>  
</body>
</html>
