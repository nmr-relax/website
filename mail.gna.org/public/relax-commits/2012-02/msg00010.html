<!-- MHonArc v2.6.16 -->
<!--X-Subject: r15295 &#45; /branches/frame_order_testing/maths_fns/frame_order.py -->
<!--X-From-R13: rqjneqNaze&#45;erynk.pbz -->
<!--X-Date: Fri, 03 Feb 2012 11:41:55 +0100 -->
<!--X-Message-Id: E1RtGaZ&#45;0004QD&#45;JN@subversion.gna.org -->
<!--X-Content-Type: text/plain -->
<!--X-Head-End-->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>r15295 - /branches/frame_order_testing/maths_fns/frame_order.py -- February 03, 2012 - 11:41</title>
<link rel="stylesheet" type="text/css" href="/archives-color-gna.css"> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<h2><img src="https://gna.org/images/gna.theme/mail.orig.png" width="48" height="48"
alt="mail" class="pageicon" />r15295 - /branches/frame_order_testing/maths_fns/frame_order.py</h2>
<br />
<div class="topmenu">
<a href="../" class="tabs">Others Months</a> | <a href="index.html#00010" class="tabs">Index by Date</a> | <a href="threads.html#00010" class="tabs">Thread Index</a><br />
<span class="smaller">&gt;&gt;&nbsp;&nbsp;
[<a href="msg00009.html">Date Prev</a>] [<a href="msg00011.html">Date Next</a>] [<a href="msg00009.html">Thread Prev</a>] [<a href="msg00011.html">Thread Next</a>]
</div>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h3><a name="header" href="#header">Header</a></h3>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul class="headdata">
<li class="menuitem">
<em>To</em>: relax-commits@xxxxxxx</li>
<li class="menuitem">
<em>Date</em>: Fri, 03 Feb 2012 10:41:55 -0000</li>
<li class="menuitem">
<em>Message-id</em>: &lt;<a href="msg00010.html">E1RtGaZ-0004QD-JN@subversion.gna.org</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
</div><!-- end headdata -->
<br />
<h3><a name="content" href="#content">Content</a></h3>
<div class="postedby">Posted by <strong>edward</strong> on February 03, 2012 - 11:41:</div>
<div class="msgdata">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre style="margin: 0em;">Author: bugman
Date: Fri Feb  3 11:41:55 2012
New Revision: 15295

URL: <a  rel="nofollow" href="http://svn.gna.org/viewcvs/relax?rev=15295&amp;view=rev">http://svn.gna.org/viewcvs/relax?rev=15295&amp;view=rev</a>
Log:
All of the non-quadratic integration frame order target functions have been 
converted to quasi-random.

This completes the update from Monte Carlo to quasi-random numerical 
integration.


Modified:
    branches/frame_order_testing/maths_fns/frame_order.py

Modified: branches/frame_order_testing/maths_fns/frame_order.py
URL: 
<a  rel="nofollow" href="http://svn.gna.org/viewcvs/relax/branches/frame_order_testing/maths_fns/frame_order.py?rev=15295&amp;r1=15294&amp;r2=15295&amp;view=diff">http://svn.gna.org/viewcvs/relax/branches/frame_order_testing/maths_fns/frame_order.py?rev=15295&amp;r1=15294&amp;r2=15295&amp;view=diff</a>
==============================================================================
--- branches/frame_order_testing/maths_fns/frame_order.py (original)
+++ branches/frame_order_testing/maths_fns/frame_order.py Fri Feb  3 11:41:55 
2012
@@ -276,28 +276,36 @@
                 self.create_sobol_data(n=self.num_int_pts, dims=['theta', 
'phi', 'sigma'])
                 self.func = self.func_pseudo_ellipse_qrint
             elif model == 'pseudo-ellipse, torsionless':
-                self.func = self.func_pseudo_ellipse_torsionless_mcint
+                self.create_sobol_data(n=self.num_int_pts, dims=['theta', 
'phi'])
+                self.func = self.func_pseudo_ellipse_torsionless_qrint
             elif model == 'pseudo-ellipse, free rotor':
-                self.func = self.func_pseudo_ellipse_free_rotor_mcint
+                self.create_sobol_data(n=self.num_int_pts, dims=['theta', 
'phi'])
+                self.func = self.func_pseudo_ellipse_free_rotor_qrint
             elif model == 'iso cone':
-                self.func = self.func_iso_cone_mcint
+                self.create_sobol_data(n=self.num_int_pts, dims=['theta', 
'sigma'])
+                self.func = self.func_iso_cone_qrint
             elif model == 'iso cone, torsionless':
-                self.func = self.func_iso_cone_torsionless_mcint
+                self.create_sobol_data(n=self.num_int_pts, dims=['theta'])
+                self.func = self.func_iso_cone_torsionless_qrint
             elif model == 'iso cone, free rotor':
-                self.func = self.func_iso_cone_free_rotor_mcint
+                self.create_sobol_data(n=self.num_int_pts, dims=['theta'])
+                self.func = self.func_iso_cone_free_rotor_qrint
             elif model == 'line':
-                self.func = self.func_line_mcint
+                self.create_sobol_data(n=self.num_int_pts, dims=['theta', 
'sigma'])
+                self.func = self.func_line_qrint
             elif model == 'line, torsionless':
-                self.func = self.func_line_torsionless_mcint
+                self.create_sobol_data(n=self.num_int_pts, dims=['theta'])
+                self.func = self.func_line_torsionless_qrint
             elif model == 'line, free rotor':
-                self.func = self.func_line_free_rotor_mcint
+                self.create_sobol_data(n=self.num_int_pts, dims=['theta'])
+                self.func = self.func_line_free_rotor_qrint
             elif model == 'rotor':
                 self.create_sobol_data(n=self.num_int_pts, dims=['sigma'])
                 self.func = self.func_rotor_qrint
             elif model == 'rigid':
                 self.func = self.func_rigid
             elif model == 'free rotor':
-                self.func = self.func_free_rotor_mcint
+                self.func = self.func_free_rotor_qrint
 
         # The target function aliases (Scipy numerical integration).
         else:
@@ -440,7 +448,7 @@
         return chi2_sum
 
 
-    def func_free_rotor_mcint(self, params):
+    def func_free_rotor_qrint(self, params):
         &quot;&quot;&quot;Target function for free rotor model optimisation.
 
         This function optimises the isotropic cone model parameters using 
the RDC and PCS base data.  Simple Monte Carlo integration is used for the 
PCS.
@@ -505,7 +513,7 @@
         # PCS via Monte Carlo integration.
         if self.pcs_flag:
             # Numerical integration of the PCSs.
-            pcs_numeric_int_rotor_qrint(N=self.num_int_pts, sigma_max=pi, 
c=self.pcs_const, full_in_ref_frame=self.full_in_ref_frame, 
r_pivot_atom=self.r_pivot_atom, r_pivot_atom_rev=self.r_pivot_atom_rev, 
r_ln_pivot=self.r_ln_pivot, A=self.A_3D, R_eigen=self.R_eigen, 
RT_eigen=RT_eigen, Ri_prime=self.Ri_prime, pcs_theta=self.pcs_theta, 
pcs_theta_err=self.pcs_theta_err, missing_pcs=self.missing_pcs, 
error_flag=False)
+            pcs_numeric_int_rotor_qrint(points=self.sobol_angles, 
sigma_max=pi, c=self.pcs_const, full_in_ref_frame=self.full_in_ref_frame, 
r_pivot_atom=self.r_pivot_atom, r_pivot_atom_rev=self.r_pivot_atom_rev, 
r_ln_pivot=self.r_ln_pivot, A=self.A_3D, R_eigen=self.R_eigen, 
RT_eigen=RT_eigen, Ri_prime=self.Ri_prime, pcs_theta=self.pcs_theta, 
pcs_theta_err=self.pcs_theta_err, missing_pcs=self.missing_pcs, 
error_flag=False)
 
             # Calculate and sum the single alignment chi-squared value (for 
the PCS).
             for i in xrange(self.num_align):
@@ -600,7 +608,7 @@
         return chi2_sum
 
 
-    def func_iso_cone_mcint(self, params):
+    def func_iso_cone_qrint(self, params):
         &quot;&quot;&quot;Target function for isotropic cone model optimisation.
 
         This function optimises the isotropic cone model parameters using 
the RDC and PCS base data.  Simple Monte Carlo integration is used for the 
PCS.
@@ -665,7 +673,7 @@
         # PCS via Monte Carlo integration.
         if self.pcs_flag:
             # Numerical integration of the PCSs.
-            pcs_numeric_int_iso_cone_mcint(N=self.num_int_pts, 
theta_max=cone_theta, sigma_max=sigma_max, c=self.pcs_const, 
full_in_ref_frame=self.full_in_ref_frame, r_pivot_atom=self.r_pivot_atom, 
r_pivot_atom_rev=self.r_pivot_atom_rev, r_ln_pivot=self.r_ln_pivot, 
A=self.A_3D, R_eigen=self.R_eigen, RT_eigen=RT_eigen, Ri_prime=self.Ri_prime, 
pcs_theta=self.pcs_theta, pcs_theta_err=self.pcs_theta_err, 
missing_pcs=self.missing_pcs, error_flag=False)
+            pcs_numeric_int_iso_cone_qrint(points=self.sobol_angles, 
theta_max=cone_theta, sigma_max=sigma_max, c=self.pcs_const, 
full_in_ref_frame=self.full_in_ref_frame, r_pivot_atom=self.r_pivot_atom, 
r_pivot_atom_rev=self.r_pivot_atom_rev, r_ln_pivot=self.r_ln_pivot, 
A=self.A_3D, R_eigen=self.R_eigen, RT_eigen=RT_eigen, Ri_prime=self.Ri_prime, 
pcs_theta=self.pcs_theta, pcs_theta_err=self.pcs_theta_err, 
missing_pcs=self.missing_pcs, error_flag=False)
 
             # Calculate and sum the single alignment chi-squared value (for 
the PCS).
             for i in xrange(self.num_align):
@@ -762,7 +770,7 @@
         return chi2_sum
 
 
-    def func_iso_cone_free_rotor_mcint(self, params):
+    def func_iso_cone_free_rotor_qrint(self, params):
         &quot;&quot;&quot;Target function for free rotor isotropic cone model optimisation.
 
         This function optimises the isotropic cone model parameters using 
the RDC and PCS base data.  Simple Monte Carlo integration is used for the 
PCS.
@@ -830,7 +838,7 @@
         # PCS via Monte Carlo integration.
         if self.pcs_flag:
             # Numerical integration of the PCSs.
-            pcs_numeric_int_iso_cone_mcint(N=self.num_int_pts, 
theta_max=theta_max, sigma_max=pi, c=self.pcs_const, 
full_in_ref_frame=self.full_in_ref_frame, r_pivot_atom=self.r_pivot_atom, 
r_pivot_atom_rev=self.r_pivot_atom_rev, r_ln_pivot=self.r_ln_pivot, 
A=self.A_3D, R_eigen=self.R_eigen, RT_eigen=RT_eigen, Ri_prime=self.Ri_prime, 
pcs_theta=self.pcs_theta, pcs_theta_err=self.pcs_theta_err, 
missing_pcs=self.missing_pcs, error_flag=False)
+            pcs_numeric_int_iso_cone_qrint(points=self.sobol_angles, 
theta_max=theta_max, sigma_max=pi, c=self.pcs_const, 
full_in_ref_frame=self.full_in_ref_frame, r_pivot_atom=self.r_pivot_atom, 
r_pivot_atom_rev=self.r_pivot_atom_rev, r_ln_pivot=self.r_ln_pivot, 
A=self.A_3D, R_eigen=self.R_eigen, RT_eigen=RT_eigen, Ri_prime=self.Ri_prime, 
pcs_theta=self.pcs_theta, pcs_theta_err=self.pcs_theta_err, 
missing_pcs=self.missing_pcs, error_flag=False)
 
             # Calculate and sum the single alignment chi-squared value (for 
the PCS).
             for i in xrange(self.num_align):
@@ -924,7 +932,7 @@
         return chi2_sum
 
 
-    def func_iso_cone_torsionless_mcint(self, params):
+    def func_iso_cone_torsionless_qrint(self, params):
         &quot;&quot;&quot;Target function for torsionless isotropic cone model optimisation.
 
         This function optimises the isotropic cone model parameters using 
the RDC and PCS base data.  Simple Monte Carlo integration is used for the 
PCS.
@@ -989,7 +997,7 @@
         # PCS via Monte Carlo integration.
         if self.pcs_flag:
             # Numerical integration of the PCSs.
-            pcs_numeric_int_iso_cone_torsionless_mcint(N=self.num_int_pts, 
theta_max=cone_theta, c=self.pcs_const, 
full_in_ref_frame=self.full_in_ref_frame, r_pivot_atom=self.r_pivot_atom, 
r_pivot_atom_rev=self.r_pivot_atom_rev, r_ln_pivot=self.r_ln_pivot, 
A=self.A_3D, R_eigen=self.R_eigen, RT_eigen=RT_eigen, Ri_prime=self.Ri_prime, 
pcs_theta=self.pcs_theta, pcs_theta_err=self.pcs_theta_err, 
missing_pcs=self.missing_pcs, error_flag=False)
+            
pcs_numeric_int_iso_cone_torsionless_qrint(points=self.sobol_angles, 
theta_max=cone_theta, c=self.pcs_const, 
full_in_ref_frame=self.full_in_ref_frame, r_pivot_atom=self.r_pivot_atom, 
r_pivot_atom_rev=self.r_pivot_atom_rev, r_ln_pivot=self.r_ln_pivot, 
A=self.A_3D, R_eigen=self.R_eigen, RT_eigen=RT_eigen, Ri_prime=self.Ri_prime, 
pcs_theta=self.pcs_theta, pcs_theta_err=self.pcs_theta_err, 
missing_pcs=self.missing_pcs, error_flag=False)
 
             # Calculate and sum the single alignment chi-squared value (for 
the PCS).
             for i in xrange(self.num_align):
@@ -1233,7 +1241,7 @@
         return chi2_sum
 
 
-    def func_pseudo_ellipse_free_rotor_mcint(self, params):
+    def func_pseudo_ellipse_free_rotor_qrint(self, params):
         &quot;&quot;&quot;Target function for free_rotor pseudo-elliptic cone model 
optimisation.
 
         This function optimises the isotropic cone model parameters using 
the RDC and PCS base data.  Simple Monte Carlo integration is used for the 
PCS.
@@ -1295,7 +1303,7 @@
         # PCS via Monte Carlo integration.
         if self.pcs_flag:
             # Numerical integration of the PCSs.
-            pcs_numeric_int_pseudo_ellipse_mcint(N=self.num_int_pts, 
theta_x=cone_theta_x, theta_y=cone_theta_y, sigma_max=pi, c=self.pcs_const, 
full_in_ref_frame=self.full_in_ref_frame, r_pivot_atom=self.r_pivot_atom, 
r_pivot_atom_rev=self.r_pivot_atom_rev, r_ln_pivot=self.r_ln_pivot, 
A=self.A_3D, R_eigen=self.R_eigen, RT_eigen=RT_eigen, Ri_prime=self.Ri_prime, 
pcs_theta=self.pcs_theta, pcs_theta_err=self.pcs_theta_err, 
missing_pcs=self.missing_pcs, error_flag=False)
+            pcs_numeric_int_pseudo_ellipse_qrint(points=self.sobol_angles, 
theta_x=cone_theta_x, theta_y=cone_theta_y, sigma_max=pi, c=self.pcs_const, 
full_in_ref_frame=self.full_in_ref_frame, r_pivot_atom=self.r_pivot_atom, 
r_pivot_atom_rev=self.r_pivot_atom_rev, r_ln_pivot=self.r_ln_pivot, 
A=self.A_3D, R_eigen=self.R_eigen, RT_eigen=RT_eigen, Ri_prime=self.Ri_prime, 
pcs_theta=self.pcs_theta, pcs_theta_err=self.pcs_theta_err, 
missing_pcs=self.missing_pcs, error_flag=False)
 
             # Calculate and sum the single alignment chi-squared value (for 
the PCS).
             for i in xrange(self.num_align):
@@ -1386,7 +1394,7 @@
         return chi2_sum
 
 
-    def func_pseudo_ellipse_torsionless_mcint(self, params):
+    def func_pseudo_ellipse_torsionless_qrint(self, params):
         &quot;&quot;&quot;Target function for torsionless pseudo-elliptic cone model 
optimisation.
 
         This function optimises the isotropic cone model parameters using 
the RDC and PCS base data.  Simple Monte Carlo integration is used for the 
PCS.
@@ -1448,7 +1456,7 @@
         # PCS via Monte Carlo integration.
         if self.pcs_flag:
             # Numerical integration of the PCSs.
-            
pcs_numeric_int_pseudo_ellipse_torsionless_mcint(N=self.num_int_pts, 
theta_x=cone_theta_x, theta_y=cone_theta_y, c=self.pcs_const, 
full_in_ref_frame=self.full_in_ref_frame, r_pivot_atom=self.r_pivot_atom, 
r_pivot_atom_rev=self.r_pivot_atom_rev, r_ln_pivot=self.r_ln_pivot, 
A=self.A_3D, R_eigen=self.R_eigen, RT_eigen=RT_eigen, Ri_prime=self.Ri_prime, 
pcs_theta=self.pcs_theta, pcs_theta_err=self.pcs_theta_err, 
missing_pcs=self.missing_pcs, error_flag=False)
+            
pcs_numeric_int_pseudo_ellipse_torsionless_qrint(points=self.sobol_angles, 
theta_x=cone_theta_x, theta_y=cone_theta_y, c=self.pcs_const, 
full_in_ref_frame=self.full_in_ref_frame, r_pivot_atom=self.r_pivot_atom, 
r_pivot_atom_rev=self.r_pivot_atom_rev, r_ln_pivot=self.r_ln_pivot, 
A=self.A_3D, R_eigen=self.R_eigen, RT_eigen=RT_eigen, Ri_prime=self.Ri_prime, 
pcs_theta=self.pcs_theta, pcs_theta_err=self.pcs_theta_err, 
missing_pcs=self.missing_pcs, error_flag=False)
 
             # Calculate and sum the single alignment chi-squared value (for 
the PCS).
             for i in xrange(self.num_align):



</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div><!-- end msgdata -->
<br />
<h3><a name="related" href="#related">Related Messages</a></h3>
<div class="relateddata">
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
</div><!-- end relateddata -->
<!-- NoBotLinksApartFromRelatedMessages -->

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
<div class="footer">You are on the <a href="http://gna.org">Gna!</a> mail server.</div><br />
<div class="right">Powered by <a href="http://www.mhonarc.org">MHonArc</a>, Updated Fri Feb 03 12:00:02 2012</div>  
</body>
</html>
