<!-- MHonArc v2.6.10 -->
<!--X-Subject: Re: multi processing -->
<!--X-From-R13: "Sqjneq q'Ohiretar" <rqjneqNaze&#45;erynk.pbz> -->
<!--X-Date: Thu, 06 Jul 2006 08:59:23 +0200 -->
<!--X-Message-Id: 7f080ed10607052358w54ce73a9x51eea6333929fe40@mail.gmail.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 445A0001.9020608@bmb.leeds.ac.uk -->
<!--X-Reference: c225763e0605041842t6b8287a0l543344ebc5514375@mail.gmail.com -->
<!--X-Reference: 7f080ed10605042156j1595407m18e4be8079b1784c@mail.gmail.com -->
<!--X-Reference: 4497C6FF.3050407@bmb.leeds.ac.uk -->
<!--X-Head-End-->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: multi processing -- July 06, 2006 - 08:59</title>
<link rel="stylesheet" type="text/css" href="/mail.gna.org/archives-color-gna.css"> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<h2><img src="/mail.gna.org/images/mail.orig.png" width="48" height="48"
alt="mail" class="pageicon" />Re: multi processing</h2>
<br />
<div class="topmenu">
<a href="../" class="tabs">Others Months</a> | <a href="index.html#00003" class="tabs">Index by Date</a> | <a href="threads.html#00003" class="tabs">Thread Index</a><br />
<span class="smaller">&gt;&gt;&nbsp;&nbsp;
[<a href="msg00002.html">Date Prev</a>] [<a href="msg00004.html">Date Next</a>] [<a href="msg00002.html">Thread Prev</a>] [<a href="msg00005.html">Thread Next</a>]
</div>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h3><a name="header" href="#header">Header</a></h3>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul class="headdata">
<li class="menuitem">
<em>To</em>: relax-devel@xxxxxxx</li>
<li class="menuitem">
<em>Date</em>: Thu, 6 Jul 2006 16:58:43 +1000</li>
<li class="menuitem">
<em>Message-id</em>: &lt;<a href="msg00003.html">7f080ed10607052358w54ce73a9x51eea6333929fe40@mail.gmail.com</a>&gt;</li>
<li class="menuitem">
<em>References</em>: &lt;445A0001.9020608@bmb.leeds.ac.uk&gt;	&lt;c225763e0605041842t6b8287a0l543344ebc5514375@mail.gmail.com&gt;	&lt;7f080ed10605042156j1595407m18e4be8079b1784c@mail.gmail.com&gt;	&lt;4497C6FF.3050407@bmb.leeds.ac.uk&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
</div><!-- end headdata -->
<br />
<h3><a name="content" href="#content">Content</a></h3>
<div class="postedby">Posted by <strong>Edward d'Auvergne</strong> on July 06, 2006 - 08:59:</div>
<div class="msgdata">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<blockquote class="blockquote"><pre style="margin: 0em;">Hi thanks for this info, as you can see from my previous e-mail I am not
going to build in a dependance on mpi in relax directly as I want to
have multiple backends. But this is till useful as I will use mpi as my
first transport for testing ;-)
</pre></blockquote><pre style="margin: 0em;"><br>Scientific is already a dependancy so if you use its MPI interface
there should be no problems.</pre><br>
<blockquote class="blockquote"><pre style="margin: 0em;">&gt; On 5/5/06, Andrew Perry &lt;ajperry@xxxxxxxxxxxxxx&gt; wrote:
&gt;
&gt;&gt;
&gt;&gt; &gt;&gt;SSH tunnels is probably not the best option for your system.  Do you
&gt;&gt; &gt;&gt;know anything about MPI?
&gt;&gt; &gt;
&gt;&gt; &gt;I have read about MPI but have not implimented anything __YET__;-).
&gt;&gt; &gt;Also
&gt;&gt; &gt;I have compiled some MPI based programs. It seems to a bit of a pig
&gt;&gt; &gt;and
&gt;&gt; &gt;I don't think the low hanging fruit necessarily require that degree of
&gt;&gt; &gt;fine grained distribution...
&gt;&gt;
&gt;&gt; If this is any help, I've done what I think is some fairly exhaustive
&gt;&gt; searching for python+mpi implementations recently. Note that I've never
&gt;&gt; _actually_ used any of them for a project yet.
&gt;&gt;
&gt;
&gt; Thanks, the info should help.
&gt;
&gt;&gt; Scientific Python has an MPI interface, which is handy since it is
&gt;&gt; already a
&gt;&gt; relax dependancy. The drawback is that its documentation seems very
&gt;&gt; geared
&gt;&gt; toward those who already understand MPI reasonably well. The other
&gt;&gt; drawback
&gt;&gt; is that is seems to be only able to pass Numpy arrays and strings
&gt;&gt; between
&gt;&gt; nodes, which would mean some relax data structures would probably
&gt;&gt; need to be
&gt;&gt; 'repackaged' for sending via MPI.
&gt;&gt; 
<a  href="http://starship.python.net/~hinsen/ScientificPython/ScientificPythonManual/Scientific_27.html">http://starship.python.net/~hinsen/ScientificPython/ScientificPythonManual/Scientific_27.html</a>
&gt;&gt;
&gt;&gt;
&gt;
I have got this one up and this is what I am going to use make my
default implementation.  The good news is that the apparent drawbacks
don't seem to bad as you can dump arbitary data to in memory files via
cpickle and then send them over the mpi link  as a byte array</pre><br>
<pre style="margin: 0em;">&gt; If the code is implemented is implemented at the analysis specific
&gt; level, for example the minimise() function in the file
&gt; 'specific_fns/model_free.py', then almost all of the data structures
&gt; are already converted to Numeric arrays.
&gt;
that neat ;-) and useful information</pre><br>
<pre style="margin: 0em;">&gt;&gt; Another one is:
&gt;&gt;  MYMPI - <a  href="http://peloton.sdsc.edu/~tkaiser/mympi/">http://peloton.sdsc.edu/~tkaiser/mympi/</a> (and
&gt;&gt; <a  href="http://grid-devel.sdsc.edu/gridsphere/gridsphere?cid=mympi">http://grid-devel.sdsc.edu/gridsphere/gridsphere?cid=mympi</a>
&gt;&gt; ) -  syntax intended to match C MPI API closely, and much like
&gt;&gt; Scientific.MPI only has direct support for some basic data types, not
&gt;&gt; arbitrary python objects.
&gt;&gt;
&gt;&gt; Most other implementations (below) support transmission of any python
&gt;&gt; object
&gt;&gt; that can be pickled, and so may take less code to implement in relax.
&gt;&gt; However, sending the whole data object when only select parts of it are
&gt;&gt; required for the calculation could be more inefficient than you would
&gt;&gt; like,
&gt;&gt; and so 'repackaging' and sending just what is needed may be better
&gt;&gt; anyway. I
&gt;&gt; wonder which is worse in this case .. the network overhead of sending a
&gt;&gt; large-ish python object, or the extra load on the 'master' node as it
&gt;&gt; repackages it to smaller Numpy array ..?? Guess it all depends on
&gt;&gt; whether
&gt;&gt; things are carved up 'batchwise' or more fine-grained (inner
&gt;&gt; loop/function
&gt;&gt; level).
&gt;&gt;
&gt;
certainly for a first implementation I am going to go batchwise
</pre></blockquote><pre style="margin: 0em;"><br>Batchwise may actually require more changes to the code and be more
difficult to setup.  Then again, batchwise may be the best option for
MPI and may remove the need for threading.  As I don't know the first
thing about MPI, do you have any opinions Andrew?</pre><br>
<blockquote class="blockquote"><pre style="margin: 0em;">&gt; What data needs to be sent depends on what level the threading will be
&gt; implemented on.  If each call to minimise() in
&gt; 'specific_fns/model_free.py' is threaded, then only the data which is
&gt; packaged within that function will need to be sent.  The node can then
&gt; return solely the minimisation results (parameter vector, iteration
&gt; count, function count, gradient count, hessian count, and warnings).
&gt; My threading code is a little higher up in the chain within the
&gt; minimise() function of the generic code (generic_fns/minimise.py)
&gt; which calls the specific model-free minimise() function.  This code
&gt; currently only works for Monte Carlo simulations.</pre><br>
<pre style="margin: 0em;">&gt;
&gt; The repackaging overhead by the master node should be tiny compared to
&gt; the calculation time.  The cost of sending data could become quite
&gt; high if the threading is fine grained enough.  What really needs to be
&gt; determined is what will be threaded.  Will individual model-free
&gt; minimisation instances be threaded?  If the diffusion tensor is fixed
&gt; then individual residue minimisations will be threaded.  If the
&gt; diffusion tensor parameters are optimised, either with or without the
&gt; model-free parameters, then there is one single instance.  If the
&gt; local tm parameter is included, then again individual residues are
&gt; optimised.  Using this fine grained approach communication to and from
&gt; the nodes will likely be expensive.</pre><br>
<pre style="margin: 0em;"><br>yep I don't intend to go fine grain at the moment, though my general
design could be expanded that way if needed</pre><br>
<pre style="margin: 0em;">&gt;
&gt; The second thing which could be threaded is the runs themselves.  For
&gt; example if models m1 to m9 are optimised normally using a Python loop
&gt; these could be threaded so that, assuming individual residue
&gt; minimisations are threaded, then model m2 calculations could start
&gt; while instances of model m1 are still being calculated on nodes.  This
&gt; could cause significant speed ups if the protein has more residues
&gt; than the cluster has nodes.  Otherwise each run could be sent to a
&gt; different node (the amount of data sent would be much larger).</pre><br>
<pre style="margin: 0em;"><br>again  I would prefer not to optimise by models, but by residues at the
moment, as the management is just so much easier
</pre></blockquote><pre style="margin: 0em;"><br>The single point in the code I talked about in the last message would
be the best target.</pre><br>
<blockquote class="blockquote"><pre style="margin: 0em;"><br>&gt;
&gt; Finally Monte Carlo simulations are the highest level and most obvious
&gt; target.  This is the part of model-free analysis which takes the
&gt; longest.
&gt;
&gt;&gt; MMPI - <a  href="http://www.penzilla.net/mmpi/">http://www.penzilla.net/mmpi/</a> - looks to be actively
&gt;&gt; developed, good
&gt;&gt; documentation with examples, including sending of python objects via
&gt;&gt; pickling.
&gt;&gt;
&gt;&gt;  pyPar -
&gt;&gt; <a  href="http://datamining.anu.edu.au/~ole/work/software/pypar/">http://datamining.anu.edu.au/~ole/work/software/pypar/</a> -
&gt;&gt; sends abitrary python objects, only two GPL licensed files so would
&gt;&gt; be very
&gt;&gt; easy to package directly with relax rather than make users chase
&gt;&gt; dependancies.
&gt;&gt;
&gt;
&gt; We could import the dependancy with a 'try:' statement so that MPI is
&gt; only a dependency for those wishing to use multiple machines.  It
&gt; looks like Pypar is dependent on a C MPI library anyway.</pre><br>
<pre style="margin: 0em;"><br>again the use of backends (which would be classes on the pythonpath)
will solve this problem. Instantion of plugins which lack the required c
libraries should obviously raise useful exceptions...
</pre></blockquote><pre style="margin: 0em;"><br>It shouldn't be an issue if Scientific MPI is used.</pre><br>
<blockquote class="blockquote"><pre style="margin: 0em;"><br>&gt;
&gt;&gt; There are also two which are parallel python interpreters that require
&gt;&gt; recompilation, and seem to work a bit differently (still getting my head
&gt;&gt; around exactly how these are meant to be used).
&gt;&gt;
&gt;&gt;  <a  href="http://www.cimec.org.ar/python/">http://www.cimec.org.ar/python/</a> - a parallel interpreter as well as
&gt;&gt; also
&gt;&gt; some MPI bindings for python. I tested the interpreter with relax and
&gt;&gt; LAM/MPI, seemed to spawn off lots of processes and run.
&gt;&gt;
&gt;&gt;  pyMPI - <a  href="http://pympi.sourceforge.net/index.html">http://pympi.sourceforge.net/index.html</a> - a
&gt;&gt; parallel python interpreter, decent docs at (
&gt;&gt; <a  href="http://heanet.dl.sourceforge.net/sourceforge/pympi/pyMPI.pdf">http://heanet.dl.sourceforge.net/sourceforge/pympi/pyMPI.pdf</a>
&gt;&gt; ), seems mature despite out of data website.
&gt;&gt;
&gt;&gt; There is also:
&gt;&gt;
&gt;&gt; MPY - <a  href="http://mpy.sourceforge.net/index.html">http://mpy.sourceforge.net/index.html</a> (seems
&gt;&gt; abandoned since 2004)
&gt;&gt;
&gt;&gt; Hope this helps ...
&gt;&gt;
&gt;&gt; Andrew
&gt;&gt;
&gt;
&gt; Would you know which of these implementations are the most mature or
&gt; the most used?  Stability would be better than fancy features.</pre><br>
<pre style="margin: 0em;">if we use transport backends  as i discuss in my previous message we can
change the implementation relativley trivially and so avoid longterm
dependancy problems
</pre></blockquote><pre style="margin: 0em;"><br>Edward</pre><br>
<br>

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div><!-- end msgdata -->
<br />
<h3><a name="related" href="#related">Related Messages</a></h3>
<div class="relateddata">
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
</div><!-- end relateddata -->
<!-- NoBotLinksApartFromRelatedMessages -->

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
<div class="footer"></div><br />
<div class="right">Powered by <a href="http://www.mhonarc.org">MHonArc</a>, Updated Tue Jul 18 09:01:04 2006</div>  
</body>
</html>
