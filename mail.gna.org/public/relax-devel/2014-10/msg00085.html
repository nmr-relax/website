<!-- MHonArc v2.6.18 -->
<!--X-Subject: Re: r26258 &#45; /trunk/pipe_control/opendx.py -->
<!--X-From-R13: "Sqjneq q'Ohiretar" &#60;rqjneqNaze&#45;erynk.pbz> -->
<!--X-Date: Mon, 13 Oct 2014 18:34:39 +0200 -->
<!--X-Message-Id: CAED9pY8urH79A4Fc2fnPPES=Rx8&#45;HMOmjkkDTbQ1oydr+U9eFw@mail.gmail.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: E1XdhOj&#45;00028l&#45;6m@subversion.gna.org -->
<!--X-Head-End-->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: r26258 - /trunk/pipe_control/opendx.py -- October 13, 2014 - 18:34</title>
<link rel="stylesheet" type="text/css" href="/mail.gna.org/archives-color-gna.css"> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<h2><img src="/mail.gna.org/images/mail.orig.png" width="48" height="48"
alt="mail" class="pageicon" />Re: r26258 - /trunk/pipe_control/opendx.py</h2>
<br />
<div class="topmenu">
<a href="../" class="tabs">Others Months</a> | <a href="index.html#00085" class="tabs">Index by Date</a> | <a href="threads.html#00085" class="tabs">Thread Index</a><br />
<span class="smaller">&gt;&gt;&nbsp;&nbsp;
[<a href="msg00084.html">Date Prev</a>] [<a href="msg00086.html">Date Next</a>] [<a href="msg00083.html">Thread Prev</a>] [<a href="msg00089.html">Thread Next</a>]
</div>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h3><a name="header" href="#header">Header</a></h3>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul class="headdata">
<li class="menuitem">
<em>To</em>: &quot;relax-devel@xxxxxxx&quot; &lt;relax-devel@xxxxxxx&gt;</li>
<li class="menuitem">
<em>Date</em>: Mon, 13 Oct 2014 18:34:08 +0200</li>
<li class="menuitem">
<em>Dkim-signature</em>: v=1; a=rsa-sha256; c=relaxed/relaxed; d=gmail.com; s=20120113; h=mime-version:sender:in-reply-to:references:date:message-id:subject :from:to:content-type; bh=99zqnGZFtZtLBRfq2BKrIDep9sA6SYfzsPLAhsTY4ik=; b=h/ZUKCzhv2Re4OXkoOdULhV1S8zM8WtS4eSU+Y63cea2GtY6HUnDa+xMyV44rVdM5q SSjl0DqljQUTjxw2CbbVn7qlEcEsS1iyNWAPKrxPq/Dy7Ff8TJujXRWlE3fLQ7AICoUh mSJKucTQvHHfgp6EqdLr6BOoR9WIe6uEAumukCDRR0FeTSjHlGeIWaM+lKzglyPp4jbN ZErUSY/G+BUKkPofnnuxhnJ5NehYZ6+lr70XrdeEJy2zlMzmB3ApHDo3OUcC6jDxYq/e wEgIeNc+tpR7JuxKJ4h5RiUWYZ6g69RwkkmdCEYW6BU72pEJfY1w+AIiehVC1ss6lfPQ hJYg==</li>
<li class="menuitem">
<em>Message-id</em>: &lt;CAED9pY8urH79A4Fc2fnPPES=Rx8-HMOmjkkDTbQ1oydr+U9eFw@mail.gmail.com&gt;</li>
<li class="menuitem">
<em>References</em>: &lt;E1XdhOj-00028l-6m@subversion.gna.org&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
</div><!-- end headdata -->
<br />
<h3><a name="content" href="#content">Content</a></h3>
<div class="postedby">Posted by <strong>Edward d'Auvergne</strong> on October 13, 2014 - 18:34:</div>
<div class="msgdata">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre style="margin: 0em;">Hi Troels,

This is clearly pushing the boundaries of this design, far beyond its
scope of OpenDX specific functionality.  Do you have other ideas of
how you would like to extend this?  Would you like relax to launch the
matplotlib viewing code as well?  A small redesign is clearly now
required to prevent the dx user functions from becoming over
complicated.  I can help with this.  From the code changes, I am
guessing that you would like to try to generalise the mapping
functionality to be software independent.  Therefore I would suggest
we do the following:

1)  Shift the Map class maybe into pipe_control.mapping.base.  This
was planned for the future anyway, but I'll wait for your response
before making changes, in case you are still working on this code.
2)  Covert the Map class into a base class (this doesn't require any changes).
3)  Create one OpenDX specific class and one matplotlib specific class
(in pipe_control.mapping.opendx and pipe_control.mapping.matplotlib).
These would then have a run() method which replaces what the current
__init__() method is doing.
4)  Rename the user_functions.dx module to user_functions.map.
5)  Rename the dx.map user function to map.dx_create.
6)  Rename the dx.execute user function to map.dx_execute.
7)  Create the new map.matplotlib_create user function.

A second idea would be:

1)  Shift the Map class maybe into pipe_control.mapping.isosurface.
2)  Rename the user_functions.dx module to user_functions.map.
3)  Rename the dx.map user function to map.create.  This would then
have options for creating the different map types, having values of
'OpenDX', 'matplotlib', and 'text' (the last is for the 4 column text
file you have already implemented).  This could be allowed to be a
list as well, if you would really like to have all maps created
simultaneously.
4)  Rename the dx.execute user function to map.dx_execute.
5)  Create the new map.matplotlib_execute user function.

The first design would be simpler, in that many more OpenDX or
matplotlib specific arguments can be added without killing the GUI
user function window.  What do you think?  Does either of these match
your aims?

An alternative idea that would be much more powerful would be to to
shift a lot of the current dx.map functionality into a new map.setup
user function.  We then store things in the current data pipe such as
cdp.map_parameters, cdp.map_type, cdp.map_inc, cdp.map_lower,
cdp.map_upper, cdp.map_axis_inc, cdp.map_points,
cdp.map_isosurface_levels.  I could also quickly create a special
Python object called cdp.map with XML methods which has the variables
stored there (e.g. cdp.map.parameters and cdp.map.type).  The new
map.setup user function would also reset the cdp.map_data or
cdp.map.data variable to an empty list.  You may like this next idea -
the Map class run() method (from the first idea above) returns all of
the chi2 values as a list.  We then store this in cdp.map.data.  Then
the next time the Map class is set up, we pass in the cdp.map.data
values.  If this list contains values, the the target function calls
via the specific analysis API are skipped.  Then if you call
map.setup, map.dx_create, map.text_create, and map.matplotlib_create,
the last two user functions will be super fast as map.dx_create would
have already generated the chi2 values.  We also then have the added
benefit of having all the base mapping data stored in relax results
and save files.

Regards,

Edward


On 13 October 2014 17:18,  &lt;tlinnet@xxxxxxxxxxxxx&gt; wrote:
</pre><blockquote class="blockquote"><pre style="margin: 0em;">Author: tlinnet
Date: Mon Oct 13 17:18:56 2014
New Revision: 26258

URL: <a  rel="nofollow" href="http://svn.gna.org/viewcvs/relax?rev=26258&amp;view=rev">http://svn.gna.org/viewcvs/relax?rev=26258&amp;view=rev</a>
Log:
Added the write out of a matplotlib command file, to plot surfaces of a dx 
map.

It uses the minimum chi2 value in the map space, to define surface 
defitions.

It creates a X,Y; X,Z; Y,Z map, where the values in the missing dimension 
has been cut at the minimum chi2 value.
For each map, it creates a projected 3d map of the parameters and the chi2 
value, and a heat map for the contours.

It also scatters the minimum chi2 value, the 4 smallest chi2 values, and 
maps any points in the point file, to a scatter point.

Mapping the points from file to map points, is done by finding the shortest 
Euclidean distance in the space from the points to any map points.

Modified:
    trunk/pipe_control/opendx.py

Modified: trunk/pipe_control/opendx.py
URL: 
<a  rel="nofollow" href="http://svn.gna.org/viewcvs/relax/trunk/pipe_control/opendx.py?rev=26258&amp;r1=26257&amp;r2=26258&amp;view=diff">http://svn.gna.org/viewcvs/relax/trunk/pipe_control/opendx.py?rev=26258&amp;r1=26257&amp;r2=26258&amp;view=diff</a>
==============================================================================
--- trunk/pipe_control/opendx.py        (original)
+++ trunk/pipe_control/opendx.py        Mon Oct 13 17:18:56 2014
@@ -174,6 +174,9 @@
         if create_par_file:
             self.create_par_chi2(file_prefix=self.file_prefix, 
par_chi2_vals=self.par_chi2_vals)

+            # Generate the matplotlib script file, to plot surfaces
+            self.matplotlib_surface_plot()
+
         ## Generate the file with parameters and associated chi2 value for 
the points send to dx.
         if self.num_points &gt;= 1 and create_par_file:
             # Calculate the parameter and associated chi2 values for the 
points.
@@ -449,3 +452,235 @@
                 string = string + &quot; &quot; + repr(val)
                 val = val + loc_inc
             self.tick_locations.append(&quot;{&quot; + string + &quot; }&quot;)
+
+
+    def matplotlib_surface_plot(self):
+        &quot;&quot;&quot;Function to write matplotlib script to plot surfaces of 
parameters.&quot;&quot;&quot;
+
+        # Add &quot;.par&quot; to file prefix
+        mapfile_name = '&quot;%s.par&quot;' % self.file_prefix
+
+        # If point file_file is different from None
+        if self.point_file != None:
+            pointfile_name = '&quot;%s.par&quot;' % self.point_file
+        else:
+            pointfile_name = &quot;None&quot;
+
+        # Open the file.
+        plot_file = open_write_file(file_name=self.file_prefix+'.py', 
dir=self.dir, force=True)
+
+        matplotlib_file = [
+            'import numpy as np'+&quot;\n&quot;,
+            'import scipy.interpolate'+&quot;\n&quot;,
+            'from numpy.ma import masked_where'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            'from mpl_toolkits.mplot3d import axes3d'+&quot;\n&quot;,
+            'import matplotlib.pyplot as plt'+&quot;\n&quot;,
+            'from matplotlib import cm'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '# Open file and get header.'+&quot;\n&quot;,
+            'mapfile_name = %s'%mapfile_name+&quot;\n&quot;,
+            'pointfile_name = %s'%pointfile_name+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            'mapfile = open(mapfile_name, &quot;r&quot;)'+&quot;\n&quot;,
+            'lines = mapfile.readlines()'+&quot;\n&quot;,
+            'mapfile.close()'+&quot;\n&quot;,
+            'header = lines[0].split()[1:]'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '# Prepare the dtype for reading file.'+&quot;\n&quot;,
+            'dtype_str = &quot;i8,f8,f8,f8,f8,i8,f8,f8,f8,f8&quot;'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            'print(&quot;Fileheader is: %s&quot;%header)'+&quot;\n&quot;,
+            'print(&quot;Value types are: %s&quot;%dtype_str)'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '# Load the data.'+&quot;\n&quot;,
+            'data = np.genfromtxt(fname=mapfile_name, dtype=dtype_str, 
names=header)'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '# Load the point data'+&quot;\n&quot;,
+            'if pointfile_name:'+&quot;\n&quot;,
+            '    # Load the point data.'+&quot;\n&quot;,
+            '    data_p = np.genfromtxt(fname=pointfile_name, 
dtype=dtype_str, names=header)'+&quot;\n&quot;,
+            '    '+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '# Define where to cut the data, as the minimum.'+&quot;\n&quot;,
+            'header_min = header[6:10]'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '# Define to cut at min map point.'+&quot;\n&quot;,
+            'map_min_par0 = data[header_min[0]][0]'+&quot;\n&quot;,
+            'map_min_par1 = data[header_min[1]][0]'+&quot;\n&quot;,
+            'map_min_par2 = data[header_min[2]][0]'+&quot;\n&quot;,
+            'map_min_chi2 = data[header_min[3]][0]'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '# Now get the headers for the data.'+&quot;\n&quot;,
+            'header_val = header[1:5]'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '# Define which 2D maps to create, as a list of 2 parameters, 
and at which third parameter to cut the values.'+&quot;\n&quot;,
+            'maps_xy = [header_val[0], header_val[1], header_val[2], 
map_min_par2]'+&quot;\n&quot;,
+            'maps_xz = [header_val[0], header_val[2], header_val[1], 
map_min_par1]'+&quot;\n&quot;,
+            'maps_yz = [header_val[1], header_val[2], header_val[0], 
map_min_par0]'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            'maps = [maps_xy, maps_xz, maps_yz]'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '# Nr of columns is number of maps.'+&quot;\n&quot;,
+            'nr_cols = 1'+&quot;\n&quot;,
+            '# Nr of rows, is 2, for 3d projection and imshow'+&quot;\n&quot;,
+            'nr_rows = 2'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '# Loop over the maps:'+&quot;\n&quot;,
+            'for x_par, y_par, z_par, z_cut in maps:'+&quot;\n&quot;,
+            '    # Define figure'+&quot;\n&quot;,
+            '    fig = plt.figure()'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '    # Define c_par'+&quot;\n&quot;,
+            '    c_par = header_val[3]'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '    # Now get the values for the map.'+&quot;\n&quot;,
+            '    map_x = data[x_par]'+&quot;\n&quot;,
+            '    map_y = data[y_par]'+&quot;\n&quot;,
+            '    map_z = data[z_par]'+&quot;\n&quot;,
+            '    map_c = data[c_par]'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '    # Now define which map to create.'+&quot;\n&quot;,
+            '    mask_xy = masked_where(map_z == z_cut, map_z)'+&quot;\n&quot;,
+            '    map_mask_x = map_x[mask_xy.mask]'+&quot;\n&quot;,
+            '    map_mask_y = map_y[mask_xy.mask]'+&quot;\n&quot;,
+            '    map_mask_c = map_c[mask_xy.mask]'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '    # Define min and max values.'+&quot;\n&quot;,
+            '    map_mask_x_min = map_mask_x.min()'+&quot;\n&quot;,
+            '    map_mask_x_max = map_mask_x.max()'+&quot;\n&quot;,
+            '    map_mask_y_min = map_mask_y.min()'+&quot;\n&quot;,
+            '    map_mask_y_max = map_mask_y.max()'+&quot;\n&quot;,
+            '    map_mask_c_min = map_mask_c.min()'+&quot;\n&quot;,
+            '    map_mask_c_max = map_mask_c.max()'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '    # Set up a regular grid of interpolation points'+&quot;\n&quot;,
+            '    int_points = 300'+&quot;\n&quot;,
+            '    xi, yi = np.linspace(map_mask_x_min, map_mask_x_max, 
int_points), np.linspace(map_mask_y_min, map_mask_y_max, int_points)'+&quot;\n&quot;,
+            '    xi, yi = np.meshgrid(xi, yi)'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '    # Interpolate to create grid'+&quot;\n&quot;,
+            '    ci = scipy.interpolate.griddata((map_mask_x, map_mask_y), 
map_mask_c, (xi, yi), method=&quot;linear&quot;)'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '    # Set which x, y, z to plot'+&quot;\n&quot;,
+            '    x_p = xi'+&quot;\n&quot;,
+            '    y_p = yi'+&quot;\n&quot;,
+            '    c_p = ci'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '    # Cut map at a certain height.'+&quot;\n&quot;,
+            '    # First get index os largest values'+&quot;\n&quot;,
+            '    #out_val = 5*map_mask_c_min'+&quot;\n&quot;,
+            '    out_val = map_mask_c_max'+&quot;\n&quot;,
+            '    ci_mask = masked_where(ci &gt;= out_val, ci)'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '    # Replace with 0.0'+&quot;\n&quot;,
+            '    ci[ci_mask.mask] = 0.0'+&quot;\n&quot;,
+            '    # Find new max'+&quot;\n&quot;,
+            '    new_max = np.max(ci)'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '    # Insert values in array.'+&quot;\n&quot;,
+            '    ci[ci_mask.mask] = new_max'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '    # Create figure and plot'+&quot;\n&quot;,
+            '    ax = fig.add_subplot(nr_rows, nr_cols, 1, 
projection=&quot;3d&quot;)'+&quot;\n&quot;,
+            '    ax.plot_surface(x_p, y_p, c_p, rstride=8, cstride=8, 
alpha=0.3)'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '    # Possible add scatter points for map.'+&quot;\n&quot;,
+            '    #ax.scatter(map_x, map_y, map_c, c=&quot;b&quot;, marker=&quot;o&quot;, 
s=5)'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '    # One could also make the mesh just from the values, but 
this require much memory.'+&quot;\n&quot;,
+            '    ##ax.scatter(x_p, y_p, c_p, c=&quot;y&quot;, marker=&quot;o&quot;, s=5)'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '    # Add contour levels on sides.'+&quot;\n&quot;,
+            '    ax.contour(x_p, y_p, c_p, zdir=&quot;z&quot;, offset=0, 
cmap=cm.coolwarm)'+&quot;\n&quot;,
+            '    ax.contour(x_p, y_p, c_p, zdir=&quot;x&quot;, 
offset=map_mask_x_min, cmap=cm.coolwarm)'+&quot;\n&quot;,
+            '    ax.contour(x_p, y_p, c_p, zdir=&quot;y&quot;, 
offset=map_mask_y_min, cmap=cm.coolwarm)'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '    # Add scatter values, for 5 lowest values.'+&quot;\n&quot;,
+            '    x_par_min = x_par + &quot;_sort&quot;'+&quot;\n&quot;,
+            '    y_par_min = y_par + &quot;_sort&quot;'+&quot;\n&quot;,
+            '    c_par_min = c_par + &quot;_sort&quot;'+&quot;\n&quot;,
+            '    mp_x = data[x_par_min][0:5]'+&quot;\n&quot;,
+            '    mp_y = data[y_par_min][0:5]'+&quot;\n&quot;,
+            '    mp_c = data[c_par_min][0:5]'+&quot;\n&quot;,
+            '    ax.scatter(mp_x[0], mp_y[0], mp_c[0], c=&quot;r&quot;, marker=&quot;o&quot;, 
s=200)'+&quot;\n&quot;,
+            '    ax.scatter(mp_x[1:], mp_y[1:], mp_c[1:], c=&quot;g&quot;, 
marker=&quot;o&quot;, s=100)'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '    # Add points from file, as the closest point in 
map.'+&quot;\n&quot;,
+            '    if pointfile_name:'+&quot;\n&quot;,
+            '        if data_p[x_par].ndim == 0:'+&quot;\n&quot;,
+            '            points_x = np.asarray([data_p[x_par]])'+&quot;\n&quot;,
+            '            points_y = np.asarray([data_p[y_par]])'+&quot;\n&quot;,
+            '        else:'+&quot;\n&quot;,
+            '            points_x = data_p[x_par]'+&quot;\n&quot;,
+            '            points_y = data_p[y_par]'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '        # Normalize, by division of largest number of 
map'+&quot;\n&quot;,
+            '        points_x_norm = points_x / map_mask_x_max'+&quot;\n&quot;,
+            '        points_y_norm = points_y / map_mask_y_max'+&quot;\n&quot;,
+            '        map_mask_x_norm = map_mask_x / map_mask_x_max'+&quot;\n&quot;,
+            '        map_mask_y_norm = map_mask_y / map_mask_y_max'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '        p_x = []'+&quot;\n&quot;,
+            '        p_y = []'+&quot;\n&quot;,
+            '        p_c = []'+&quot;\n&quot;,
+            '        # Now calculate the Euclidean distance in the space, 
to find map point best represents the point.'+&quot;\n&quot;,
+            '        for i, point_x_norm in 
enumerate(points_x_norm):'+&quot;\n&quot;,
+            '            point_y_norm = points_y_norm[i]'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '            # Get the distance.'+&quot;\n&quot;,
+            '            dist = np.sqrt( (map_mask_x_norm - 
point_x_norm)**2 + (map_mask_y_norm - point_y_norm)**2)'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '            # Return the indices of the minimum values along 
an axis.'+&quot;\n&quot;,
+            '            min_index = np.argmin(dist)'+&quot;\n&quot;,
+            '            p_x.append(map_mask_x[min_index])'+&quot;\n&quot;,
+            '            p_y.append(map_mask_y[min_index])'+&quot;\n&quot;,
+            '            p_c.append(map_mask_c[min_index])'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '        # Convert to numpy array'+&quot;\n&quot;,
+            '        p_x = np.asarray(p_x)'+&quot;\n&quot;,
+            '        p_y = np.asarray(p_y)'+&quot;\n&quot;,
+            '        p_c = np.asarray(p_c)'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '        # Plot points'+&quot;\n&quot;,
+            '        ax.scatter(p_x, p_y, p_c, c=&quot;m&quot;, marker=&quot;o&quot;, 
s=50)'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '    # Set label'+&quot;\n&quot;,
+            '    ax.set_xlabel(&quot;%s&quot;%x_par)'+&quot;\n&quot;,
+            '    ax.set_ylabel(&quot;%s&quot;%y_par)'+&quot;\n&quot;,
+            '    ax.set_zlabel(&quot;%s&quot;%c_par)'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '    # Create figure and plot'+&quot;\n&quot;,
+            '    ax = fig.add_subplot(nr_rows, nr_cols, 2)'+&quot;\n&quot;,
+            '    fig_imshow = ax.imshow(ci, vmin=map_mask_c_min, 
vmax=map_mask_c_max, origin=&quot;lower&quot;, extent=[map_mask_x_min, 
map_mask_x_max, map_mask_y_min, map_mask_y_max])'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '    # Add scatter values, for 5 lowest values.'+&quot;\n&quot;,
+            '    ax.scatter(mp_x[0], mp_y[0], c=mp_c[0], marker=&quot;o&quot;, 
s=200)'+&quot;\n&quot;,
+            '    ax.scatter(mp_x[1:], mp_y[1:], c=&quot;g&quot;, marker=&quot;o&quot;, 
s=100)'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '    # Also add point to this map.'+&quot;\n&quot;,
+            '    if pointfile_name:'+&quot;\n&quot;,
+            '        # Plot points'+&quot;\n&quot;,
+            '        ax.scatter(p_x, p_y, c=&quot;m&quot;, marker=&quot;o&quot;, s=50)'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '    # Set label'+&quot;\n&quot;,
+            '    ax.set_xlabel(&quot;%s&quot;%x_par)'+&quot;\n&quot;,
+            '    ax.set_ylabel(&quot;%s&quot;%y_par)'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '    # Add colorbar.'+&quot;\n&quot;,
+            '    fig.subplots_adjust(right=0.8)'+&quot;\n&quot;,
+            '    cbar_ax = fig.add_axes([0.85, 0.15, 0.05, 0.3])'+&quot;\n&quot;,
+            '    fig.colorbar(fig_imshow, cax=cbar_ax)'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+            '# Show plot.'+&quot;\n&quot;,
+            'plt.show()'+&quot;\n&quot;,
+            ''+&quot;\n&quot;,
+        ]
+
+        # Loop over the lines and write.
+        for line in matplotlib_file:
+            plot_file.write(line)
+
+        # Close the file.
+        plot_file.close()


_______________________________________________
relax (<a  rel="nofollow" href="http://www.nmr-relax.com">http://www.nmr-relax.com</a>)

This is the relax-commits mailing list
relax-commits@xxxxxxx

To unsubscribe from this list, get a password
reminder, or change your subscription options,
visit the list information page at
<a  rel="nofollow" href="https://mail.gna.org/listinfo/relax-commits">https://mail.gna.org/listinfo/relax-commits</a>
</pre></blockquote><pre style="margin: 0em;">


</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div><!-- end msgdata -->
<br />
<h3><a name="related" href="#related">Related Messages</a></h3>
<div class="relateddata">
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00089" href="msg00089.html">Re: r26258 - /trunk/pipe_control/opendx.py</a></strong>
<ul><li><em>From:</em> Troels Emtek√¶r Linnet</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
</div><!-- end relateddata -->
<!-- NoBotLinksApartFromRelatedMessages -->

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
<div class="footer"></div><br />
<div class="right">Powered by <a href="http://www.mhonarc.org">MHonArc</a>, Updated Mon Oct 13 20:20:13 2014</div>  
</body>
</html>
