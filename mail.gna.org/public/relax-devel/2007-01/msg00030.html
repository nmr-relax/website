<!-- MHonArc v2.6.10 -->
<!--X-Subject: Re: Redesign of the relax data model: 3. Molecules, residues,	and spins -->
<!--X-From-R13: "Sqjneq q'Ohiretar" <rqjneq.qnhiretarNtznvy.pbz> -->
<!--X-Date: Mon, 15 Jan 2007 09:17:58 +0100 -->
<!--X-Message-Id: 7f080ed10701150017t2452571fra98f6d02bda7602b@mail.gmail.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: f001463a0701071417w6bd7927cp8fdd052e698575ec@mail.gmail.com -->
<!--X-Head-End-->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: Redesign of the relax data model: 3. Molecules, residues,	and spins -- January 15, 2007 - 09:17</title>
<link rel="stylesheet" type="text/css" href="/mail.gna.org/archives-color-gna.css"> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<h2><img src="/mail.gna.org/images/mail.orig.png" width="48" height="48"
alt="mail" class="pageicon" />Re: Redesign of the relax data model: 3. Molecules, residues,	and spins</h2>
<br />
<div class="topmenu">
<a href="../" class="tabs">Others Months</a> | <a href="index.html#00030" class="tabs">Index by Date</a> | <a href="threads.html#00030" class="tabs">Thread Index</a><br />
<span class="smaller">&gt;&gt;&nbsp;&nbsp;
[<a href="msg00029.html">Date Prev</a>] [<a href="msg00031.html">Date Next</a>] [<a href="msg00041.html">Thread Prev</a>] [<a href="msg00031.html">Thread Next</a>]
</div>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h3><a name="header" href="#header">Header</a></h3>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul class="headdata">
<li class="menuitem">
<em>To</em>: &quot;gary thompson&quot; &lt;garyt@xxxxxxxxxxxxxxx&gt;</li>
<li class="menuitem">
<em>Date</em>: Mon, 15 Jan 2007 19:17:05 +1100</li>
<li class="menuitem">
<em>Cc</em>: relax-devel@xxxxxxx</li>
<li class="menuitem">
<em>Message-id</em>: &lt;<a href="msg00030.html">7f080ed10701150017t2452571fra98f6d02bda7602b@mail.gmail.com</a>&gt;</li>
<li class="menuitem">
<em>References</em>: &lt;<a href="msg00014.html">f001463a0701071417w6bd7927cp8fdd052e698575ec@mail.gmail.com</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
</div><!-- end headdata -->
<br />
<h3><a name="content" href="#content">Content</a></h3>
<div class="postedby">Posted by <strong>Edward d'Auvergne</strong> on January 15, 2007 - 09:17:</div>
<div class="msgdata">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<tt>On 1/8/07, gary thompson &lt;garyt@xxxxxxxxxxxxxxx&gt; wrote:
</tt><blockquote class="blockquote"><pre style="margin: 0em;">&gt;   On Wed, 2006-10-11 at 17:02 +1000, Edward d'Auvergne wrote:
&gt;
</pre></blockquote><pre style="margin: 0em;"><br>[snip]</pre><br>
<blockquote class="blockquote"><pre style="margin: 0em;">&gt;   Before reading this post, please read the previous posts:
&gt;
&gt;   * The parent message 'Redesign of the relax data model:  A HOWTO for
&gt;   breaking relax.' located at
&gt;   <a  href="/mail.gna.org/public/relax-devel/2006-10/msg00053.html">https://mail.gna.org/public/relax-devel/2006-10/msg00053.html</a>
&gt;   (Message-id:
&gt;   &lt;1160550133.9523.54.camel@xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&gt;).
&gt;
&gt;   * Section 1 'Redesign of the relax data model:  1.  Why change?' located
&gt;   at <a  href="/mail.gna.org/public/relax-devel/2006-10/msg00054.html">https://mail.gna.org/public/relax-devel/2006-10/msg00054.html</a>
&gt;   (Message-id:
&gt;   &lt;1160551172.9523.60.camel@xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&gt;).
&gt;
&gt;   * Section 2 'Redesign of the relax data model:  2.  A new run concept'
&gt;   located at <a  href="/mail.gna.org/public/relax-devel/2006-10/msg00056.html">https://mail.gna.org/public/relax-devel/2006-10/msg00056.html</a>
&gt;   (Message-id:
&gt;   &lt;1160555137.9523.70.camel@xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&gt;).
&gt;
&gt;
&gt;
&gt;   3.  Molecules, residues, and spins
&gt;
</pre></blockquote><pre style="margin: 0em;"><br>[snip]</pre><br>
<blockquote class="blockquote"><pre style="margin: 0em;">&gt;   3.2  The data selection concept - identifying spin systems
&gt;
&gt;   3.2.1  Function arguments
&gt;
&gt;   The current way that spins are identified in the user functions (as well
&gt;   as internal relax functions) is through the residue number and/or
&gt;   residue name.  There is no formal or consistent way that this is done
&gt;   though.  Some arguments are called 'res_num' while others are just
&gt;   'num'.  The proposal is to standardise the interface and create the file
&gt;   called 'generic_fns/spin_selector.py'.  Using the three-level spin data
&gt;   model introduced in section 3.1, six identifiers are possible.  These
&gt;   are:
&gt;
&gt;   Molecule number, 'data.mol[0].num' (e.g. the NMR model number).
&gt;   Molecule name,   'data.mol[0].name' (e.g. the chain or segment ID).
&gt;   Residue number,  'data.mol[0].res[0].num'.
&gt;   Residue name,    'data.mol[0].res[0].name'.
&gt;   Atom number,     'data.mol[0].res[0].spin[0].num' (e.g. the PDB atom
&gt;   number).
&gt;   Atom name,       'data.mol[0].res[0].spin[0].name' (e.g. the PDB atom
&gt;   name).
&gt;
&gt;   These could be synonymous with the spin identifying function arguments
&gt;   'mol_num', 'mol_name', 'res_num', 'res_name', 'atom_num', and
&gt;   'atom_name'.  These would all default to the inactive value of None and
&gt;   would be the very last arguments of the relevant user functions.  Are
&gt;   there other ways that a spin or set of spins be identified?</pre><br>
<pre style="margin: 0em;">one answer would be to use a little language concept. Thus for example
Molmol and the UCSF systems use</pre><br>
<pre style="margin: 0em;">#&lt;molecule number&gt; | &lt;molecule_name&gt;:&lt;residue_selection&gt;[,
&lt;residue_selection&gt;...]@&lt;atom_selection&gt; [,&lt;atom_selection&gt;]</pre><br>
<pre style="margin: 0em;">residue_selection=&lt;residue_number&gt; | &lt;residue_range&gt; | &lt;residue_type&gt;
residue_selection=&lt;residue_number&gt;-&lt;residue_number&gt;
atom_selection=&lt;string_and_wildcards&gt;and Note thuis</pre><br>
<pre style="margin: 0em;"><br>this reduces selection to a single argument plus a simple parser which
would yield selection objects which can identify if a
molecule/residue/spin selection is selected and be passed around the
system. Having selection object engenders clarity and simplicity:</pre><br>
<pre style="margin: 0em;">e.g.</pre><br>
<pre style="margin: 0em;">class selection:
   def selected_spins(self):
        '''returns an iterator of spins which are selected where a spin is
a reference to a spin in the form
'self.relax.data.mol[0].res[16].spin[3]'''</pre><br>
<pre style="margin: 0em;"><br>This allows for considerable flexibility for the user and a simple
internal structure
</pre></blockquote><pre style="margin: 0em;"><br>This is a much better way of selecting spin systems!  Is there a
reference for this specification?  Duplicating the reference in the
user function docstrings to explain how to use this argument would be
important.  Does anyone know alternatives to this?</pre><br>
<br>
<blockquote class="blockquote"><pre style="margin: 0em;">&gt;   3.4  The spin loop
&gt;</pre><br>
<tt>wouldn't a function that returned an iterator be better?
</tt></blockquote><pre style="margin: 0em;"><br>That would be much better.  Originally I designed relax to use as
little of the Python language specific features as possible.  The
reason was to enable relax or parts of relax to be ported to other
languages (like relax's C modules).  This is of little importance now
as all the number crunching, CPU intensive code is located in the
'math_fns' directory.  Using a generator/iterator through the yield
statement would be a much cleaner solution.</pre><br>
<br>
<blockquote class="blockquote"><pre style="margin: 0em;">&gt;   Many parts of relax require looping over all the relaxation data (or
&gt;   spins).  The implementation of this proposal will require nested looping
&gt;   over all molecules, all residues, and all spins combined with tests for
&gt;   matches to the 'mol_num', 'mol_name', 'res_num', 'res_name', 'atom_num',
&gt;   and 'atom_name' arguments.  Rather than implementing this numerous times
&gt;   throughout the program, the loop could be implemented just once within
&gt;   the function 'self.relax.generic_fns.spin_selector.spin_loop()'.  In
&gt;   addition to the six identifiers, this new function could except as an
&gt;   argument a spin-specific function passed by the part of the code
&gt;   requesting the loop.  The 'spin_loop()' function will then pass the data
&gt;   structure 'spin', which is for example an alias to
&gt;   'self.relax.data.mol[0].res[16].spin[3]', to the spin-specific function.
&gt;   A sample implementation of the loop function could be:
&gt;
&gt;
&gt;       def spin_loop(fn=None, mol_num=None, mol_name=None, res_num=None,
&gt;   res_name=None, atom_num=None, atom_name=None):
&gt;           &quot;&quot;&quot;Function for selectively looping over all spins.&quot;&quot;&quot;
&gt;
&gt;           # Reassign the data container.
&gt;           data = self.relax.data[self.relax.run]
&gt;
&gt;           # Loop over the molecules.
&gt;           for mol in data.mol:
&gt;               # Skip the molecule if there is no match to 'mol_num'.
&gt;               if type(mol_num) == int and not mol.num == mol_num:
&gt;                   continue
&gt;               elif type(mol_num) == str and not match(mol_num, `mol.num`):
&gt;                   continue
&gt;
&gt;               # Skip the molecule if there is no match to 'mol_name'.
&gt;               if mol_name != None and not match(mol_name, `mol.name`):
&gt;                   continue
&gt;
&gt;               # Loop over the residues.
&gt;               for res in mol.res:
&gt;                   # Skip the residue if there is no match to 'res_num'.
&gt;                   if type(res_num) == int and not res.num == res_num:
&gt;                       continue
&gt;                   elif type(res_num) == str and not match(res_num,
&gt;   `res.num`):
&gt;                       continue
&gt;
&gt;                   # Skip the residue if there is no match to 'res_name'.
&gt;                   if res_name != None and not match(res_name, `res.name`):
&gt;                       continue
&gt;
&gt;                   # Loop over the spins.
&gt;                   for spin in res.spin:
&gt;                       # Skip the spin if there is no match to 'atom_num'.
&gt;                       if type(atom_num) == int and not spin.num ==
&gt;   atom_num:
&gt;                           continue
&gt;                       elif type(atom_num) == str and not match(atom_num,
&gt;   `spin.num`):
&gt;                           continue
&gt;
&gt;                       # Skip the spin if there is no match to 'atom_name'.
&gt;                       if atom_name != None and not match(atom_name,
&gt;   `spin.name`):
&gt;                           continue
&gt;
&gt;                       # Execute the supplied spin-specific function,
&gt;   passing in the data for the current spin.
&gt;                       fn(spin)
&gt;
&gt;
&gt;   It will be up to the spin-specific function passed in by the calling
&gt;   function to handle the 'spin.select' value.  Because of the complexity
&gt;   of the loop, the use of this single 'spin_loop()' function will simplify
&gt;   the relax code base, will minimise potential bugs, and will simplify
&gt;   future changes to the relax data model (if necessary).</pre><br>
<pre style="margin: 0em;">use of an iterator object will provide flexibility as iterators can be
wrapped filtered and generally mucked about with using pythons loops
and iter tools. Whats more they are  doddle to code as all you do is
write an ordinary function and call yield with a value each time you
have  identified a selected spin
(<a  href="http://www.python.org/dev/peps/pep-0255/">http://www.python.org/dev/peps/pep-0255/</a>).... This also allows
arbitrary selection to be added as wrapper iterators or filtered
iterators
</pre></blockquote><pre style="margin: 0em;"><br>Writing a function which yields the spin system specific data
container would be better  I'll get to the rest of your post Gary in a
second email.</pre><br>
<pre style="margin: 0em;">Cheers,</pre><br>
<pre style="margin: 0em;">Edward</pre><br>
<br>

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div><!-- end msgdata -->
<br />
<h3><a name="related" href="#related">Related Messages</a></h3>
<div class="relateddata">
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00014" href="msg00014.html">re: Redesign of the relax data model: 3. Molecules, residues,	and spins</a></strong>
<ul><li><em>From:</em> gary thompson</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
</div><!-- end relateddata -->
<!-- NoBotLinksApartFromRelatedMessages -->

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
<div class="footer"></div><br />
<div class="right">Powered by <a href="http://www.mhonarc.org">MHonArc</a>, Updated Fri Jan 19 13:20:19 2007</div>  
</body>
</html>
